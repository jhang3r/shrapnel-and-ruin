# BetterGame Mech Card Game Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a mobile-first, real-time multiplayer mech combat card game as a SvelteKit PWA with Supabase backend.

**Architecture:** Server-authoritative game logic in Supabase Edge Functions; Supabase Realtime broadcasts game state to all players; SvelteKit frontend subscribes and renders reactively. All game mutations go through Edge Functions — the client never writes game state directly.

**Tech Stack:** SvelteKit + TypeScript + Tailwind, Supabase (Postgres + Edge Functions + Realtime + Auth + Storage), Vitest (unit), Playwright (e2e)

---

## Task 1: Project Scaffold

**Files:**
- Create: `package.json`, `svelte.config.js`, `vite.config.ts`, `tsconfig.json`
- Create: `src/app.html`, `src/app.css`, `src/routes/+layout.svelte`
- Create: `.env.example`

**Step 1: Init SvelteKit project**

```bash
npm create svelte@latest . -- --template skeleton --types typescript --no-prettier --no-eslint --no-playwright --no-vitest
npm install
```

Expected: project scaffold with `src/routes/+page.svelte` present.

**Step 2: Install dependencies**

```bash
npm install @supabase/supabase-js @supabase/ssr tailwindcss @tailwindcss/vite
npm install -D vitest @vitest/ui jsdom @testing-library/svelte @testing-library/jest-dom
npx tailwindcss init
```

**Step 3: Configure Tailwind in vite.config.ts**

```typescript
import { sveltekit } from '@sveltejs/kit/vite';
import tailwindcss from '@tailwindcss/vite';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [tailwindcss(), sveltekit()],
  test: {
    include: ['src/**/*.{test,spec}.ts'],
    environment: 'jsdom',
    globals: true,
    setupFiles: ['src/test-setup.ts']
  }
});
```

**Step 4: Add Tailwind import to src/app.css**

```css
@import "tailwindcss";
```

**Step 5: Create src/app.html**

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%sveltekit.assets%/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <meta name="theme-color" content="#0f172a" />
    %sveltekit.head%
  </head>
  <body data-sveltekit-preload-data="hover" class="bg-slate-950 text-slate-100 min-h-screen">
    <div style="display: contents">%sveltekit.body%</div>
  </body>
</html>
```

**Step 6: Create .env.example**

```
PUBLIC_SUPABASE_URL=https://your-project.supabase.co
PUBLIC_SUPABASE_ANON_KEY=your-anon-key
```

**Step 7: Create src/test-setup.ts**

```typescript
import '@testing-library/jest-dom';
```

**Step 8: Verify dev server starts**

```bash
npm run dev
```

Expected: server at localhost:5173, no errors.

**Step 9: Commit**

```bash
git init
git add .
git commit -m "feat: init SvelteKit project with Tailwind and Vitest"
```

---

## Task 2: Supabase Project & Database Schema

**Files:**
- Create: `supabase/migrations/0001_initial_schema.sql`
- Create: `supabase/config.toml` (generated by CLI)

**Step 1: Init Supabase locally**

```bash
npx supabase init
npx supabase start
```

Expected: local Supabase running, studio at localhost:54323.

**Step 2: Write migration — core tables**

Create `supabase/migrations/0001_initial_schema.sql`:

```sql
-- Extensions
create extension if not exists "pgcrypto";

-- Profiles (extends auth.users)
create table public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  username text unique not null,
  scrap integer not null default 0,
  is_guest boolean not null default false,
  created_at timestamptz not null default now()
);
alter table public.profiles enable row level security;
create policy "Users can read own profile" on public.profiles for select using (auth.uid() = id);
create policy "Users can update own profile" on public.profiles for update using (auth.uid() = id);

-- Card definitions
create table public.card_definitions (
  id text primary key, -- e.g. "0301-REAPER", "FRAME-001"
  name text not null,
  type text not null check (type in ('frame','component','action','energy','armor')),
  rarity text not null check (rarity in ('common','uncommon','rare','epic','legendary')),
  point_cost integer not null check (point_cost between 1 and 10),
  stats jsonb not null default '{}',
  discard_effect jsonb not null default '{}',
  image_url text,
  is_starter boolean not null default false,
  created_at timestamptz not null default now()
);

-- User collections
create table public.user_collections (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  card_id text not null references public.card_definitions(id),
  quantity integer not null default 1 check (quantity >= 0),
  is_starter boolean not null default false,
  unique(user_id, card_id)
);
alter table public.user_collections enable row level security;
create policy "Users can read own collection" on public.user_collections for select using (auth.uid() = user_id);

-- Decks
create table public.decks (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  name text not null,
  is_starter boolean not null default false,
  created_at timestamptz not null default now()
);
alter table public.decks enable row level security;
create policy "Users can manage own decks" on public.decks for all using (auth.uid() = user_id);

-- Deck cards
create table public.deck_cards (
  id uuid primary key default gen_random_uuid(),
  deck_id uuid not null references public.decks(id) on delete cascade,
  card_id text not null references public.card_definitions(id),
  quantity integer not null default 1 check (quantity between 1 and 4),
  unique(deck_id, card_id)
);
alter table public.deck_cards enable row level security;
create policy "Users can manage cards in own decks" on public.deck_cards for all
  using (exists (select 1 from public.decks d where d.id = deck_id and d.user_id = auth.uid()));

-- Game rooms
create table public.game_rooms (
  id uuid primary key default gen_random_uuid(),
  room_code char(6) unique not null,
  status text not null default 'pending' check (status in ('pending','in_progress','completed')),
  max_players integer not null default 4 check (max_players between 2 and 4),
  host_id uuid references public.profiles(id),
  created_at timestamptz not null default now()
);
alter table public.game_rooms enable row level security;
create policy "Anyone can read rooms" on public.game_rooms for select using (true);

-- Game players
create table public.game_players (
  id uuid primary key default gen_random_uuid(),
  room_id uuid not null references public.game_rooms(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  deck_id uuid references public.decks(id),
  is_ready boolean not null default false,
  seat_order integer,
  unique(room_id, user_id)
);
alter table public.game_players enable row level security;
create policy "Players in room can read game_players" on public.game_players for select using (true);

-- Game state
create table public.game_state (
  id uuid primary key default gen_random_uuid(),
  room_id uuid unique not null references public.game_rooms(id) on delete cascade,
  state jsonb not null default '{}',
  phase text not null default 'upkeep' check (phase in ('upkeep','build','combat','end')),
  turn_number integer not null default 1,
  active_player_id uuid references public.profiles(id),
  updated_at timestamptz not null default now()
);
alter table public.game_state enable row level security;
create policy "Anyone can read game state" on public.game_state for select using (true);

-- Match history
create table public.match_history (
  id uuid primary key default gen_random_uuid(),
  room_id uuid references public.game_rooms(id),
  winner_id uuid references public.profiles(id),
  duration_seconds integer,
  completed_at timestamptz not null default now()
);

-- Match players (per-player results)
create table public.match_players (
  id uuid primary key default gen_random_uuid(),
  match_id uuid not null references public.match_history(id) on delete cascade,
  user_id uuid not null references public.profiles(id),
  placement integer not null,
  salvaged_card_ids text[] not null default '{}'
);

-- P2P Trades
create table public.trades (
  id uuid primary key default gen_random_uuid(),
  initiator_id uuid not null references public.profiles(id),
  recipient_id uuid not null references public.profiles(id),
  offered_card_ids text[] not null,
  requested_card_ids text[] not null,
  status text not null default 'pending' check (status in ('pending','accepted','rejected','cancelled')),
  created_at timestamptz not null default now()
);

-- Packs
create table public.packs (
  id text primary key, -- 'standard', 'advanced', 'elite'
  name text not null,
  rarity_weights jsonb not null -- { common: 60, uncommon: 25, rare: 10, epic: 4, legendary: 1 }
);
```

**Step 3: Apply migration**

```bash
npx supabase db push
```

Expected: migration applied, no errors.

**Step 4: Seed pack definitions**

Create `supabase/seed.sql`:

```sql
insert into public.packs (id, name, rarity_weights) values
  ('standard', 'Standard Pack', '{"common":65,"uncommon":25,"rare":8,"epic":2,"legendary":0}'),
  ('advanced', 'Advanced Pack', '{"common":45,"uncommon":30,"rare":17,"epic":7,"legendary":1}'),
  ('elite',    'Elite Pack',    '{"common":20,"uncommon":30,"rare":30,"epic":15,"legendary":5}');
```

**Step 5: Apply seed**

```bash
npx supabase db reset
```

Expected: schema + seed applied clean.

**Step 6: Commit**

```bash
git add supabase/
git commit -m "feat: add initial database schema and pack seed data"
```

---

## Task 3: Supabase Client & Auth

**Files:**
- Create: `src/lib/supabase.ts`
- Create: `src/lib/auth.ts`
- Create: `src/hooks.server.ts`
- Create: `src/routes/+layout.server.ts`
- Create: `src/routes/+layout.svelte`

**Step 1: Write test for auth helpers**

Create `src/lib/auth.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';

// We test the pure logic helpers — not supabase calls directly
describe('generateGuestUsername', () => {
  it('returns a string starting with Pilot', async () => {
    const { generateGuestUsername } = await import('./auth');
    const name = generateGuestUsername();
    expect(name).toMatch(/^Pilot-[A-Z0-9]{4}$/);
  });
});
```

**Step 2: Run test to verify it fails**

```bash
npm run test -- auth.test
```

Expected: FAIL — module not found.

**Step 3: Create src/lib/supabase.ts**

```typescript
import { createBrowserClient, createServerClient, isBrowser } from '@supabase/ssr';
import { PUBLIC_SUPABASE_URL, PUBLIC_SUPABASE_ANON_KEY } from '$env/static/public';
import type { Database } from './database.types';

export function createClient() {
  return createBrowserClient<Database>(PUBLIC_SUPABASE_URL, PUBLIC_SUPABASE_ANON_KEY);
}

export function createServerSupabaseClient(
  cookies: { get: (name: string) => string | undefined; set: (name: string, value: string, opts: object) => void; delete: (name: string, opts: object) => void }
) {
  return createServerClient<Database>(PUBLIC_SUPABASE_URL, PUBLIC_SUPABASE_ANON_KEY, { cookies });
}
```

**Step 4: Create src/lib/auth.ts**

```typescript
export function generateGuestUsername(): string {
  const suffix = Math.random().toString(36).slice(2, 6).toUpperCase();
  return `Pilot-${suffix}`;
}
```

**Step 5: Run test to verify it passes**

```bash
npm run test -- auth.test
```

Expected: PASS.

**Step 6: Create src/hooks.server.ts**

```typescript
import { createServerSupabaseClient } from '$lib/supabase';
import type { Handle } from '@sveltejs/kit';

export const handle: Handle = async ({ event, resolve }) => {
  event.locals.supabase = createServerSupabaseClient({
    get: (name) => event.cookies.get(name),
    set: (name, value, opts) => event.cookies.set(name, value, { path: '/', ...opts }),
    delete: (name, opts) => event.cookies.delete(name, { path: '/', ...opts })
  });

  event.locals.safeGetSession = async () => {
    const { data: { session } } = await event.locals.supabase.auth.getSession();
    if (!session) return { session: null, user: null };
    const { data: { user }, error } = await event.locals.supabase.auth.getUser();
    if (error) return { session: null, user: null };
    return { session, user };
  };

  return resolve(event, {
    filterSerializedResponseHeaders(name) {
      return name === 'content-range' || name === 'x-supabase-api-version';
    }
  });
};
```

**Step 7: Create src/app.d.ts**

```typescript
import type { SupabaseClient, Session, User } from '@supabase/supabase-js';
import type { Database } from '$lib/database.types';

declare global {
  namespace App {
    interface Locals {
      supabase: SupabaseClient<Database>;
      safeGetSession: () => Promise<{ session: Session | null; user: User | null }>;
    }
    interface PageData {
      session: Session | null;
      user: User | null;
    }
  }
}
export {};
```

**Step 8: Generate database types**

```bash
npx supabase gen types typescript --local > src/lib/database.types.ts
```

**Step 9: Create src/routes/+layout.server.ts**

```typescript
import type { LayoutServerLoad } from './$types';

export const load: LayoutServerLoad = async ({ locals }) => {
  const { session, user } = await locals.safeGetSession();
  return { session, user };
};
```

**Step 10: Update src/routes/+layout.svelte**

```svelte
<script lang="ts">
  import '../app.css';
  import { createClient } from '$lib/supabase';
  import { invalidate } from '$app/navigation';
  import { onMount } from 'svelte';

  let { data, children } = $props();
  const supabase = createClient();

  onMount(() => {
    const { data: { subscription } } = supabase.auth.onAuthStateChange((event, _session) => {
      if (event !== 'INITIAL_SESSION') {
        invalidate('supabase:auth');
      }
    });
    return () => subscription.unsubscribe();
  });
</script>

{@render children()}
```

**Step 11: Commit**

```bash
git add src/
git commit -m "feat: add Supabase client, auth helpers, and SvelteKit hooks"
```

---

## Task 4: Auth UI — Login / Register / Guest

**Files:**
- Create: `src/routes/auth/+page.svelte`
- Create: `src/routes/auth/+page.server.ts`
- Modify: `src/routes/+page.svelte`

**Step 1: Create auth page server**

Create `src/routes/auth/+page.server.ts`:

```typescript
import { redirect, fail } from '@sveltejs/kit';
import type { Actions, PageServerLoad } from './$types';
import { generateGuestUsername } from '$lib/auth';

export const load: PageServerLoad = async ({ locals }) => {
  const { user } = await locals.safeGetSession();
  if (user) redirect(303, '/lobby');
};

export const actions: Actions = {
  login: async ({ request, locals }) => {
    const data = await request.formData();
    const email = data.get('email') as string;
    const password = data.get('password') as string;
    const { error } = await locals.supabase.auth.signInWithPassword({ email, password });
    if (error) return fail(400, { message: error.message });
    redirect(303, '/lobby');
  },

  register: async ({ request, locals }) => {
    const data = await request.formData();
    const email = data.get('email') as string;
    const password = data.get('password') as string;
    const username = data.get('username') as string;
    const { data: authData, error } = await locals.supabase.auth.signUp({ email, password });
    if (error) return fail(400, { message: error.message });
    if (authData.user) {
      await locals.supabase.from('profiles').insert({
        id: authData.user.id,
        username,
        is_guest: false
      });
    }
    redirect(303, '/lobby');
  },

  guest: async ({ locals }) => {
    const username = generateGuestUsername();
    const { data: authData, error } = await locals.supabase.auth.signInAnonymously();
    if (error) return fail(400, { message: error.message });
    if (authData.user) {
      await locals.supabase.from('profiles').insert({
        id: authData.user.id,
        username,
        is_guest: true
      });
    }
    redirect(303, '/lobby');
  },

  logout: async ({ locals }) => {
    await locals.supabase.auth.signOut();
    redirect(303, '/auth');
  }
};
```

**Step 2: Create auth page UI**

Create `src/routes/auth/+page.svelte`:

```svelte
<script lang="ts">
  import type { ActionData } from './$types';
  let { form }: { form: ActionData } = $props();
  let mode = $state<'login' | 'register'>('login');
</script>

<div class="min-h-screen flex items-center justify-center p-4">
  <div class="w-full max-w-sm space-y-4">
    <h1 class="text-2xl font-bold text-center">BetterGame</h1>

    {#if form?.message}
      <p class="text-red-400 text-sm text-center">{form.message}</p>
    {/if}

    <div class="flex rounded overflow-hidden border border-slate-700">
      <button onclick={() => mode = 'login'}
        class="flex-1 py-2 text-sm {mode === 'login' ? 'bg-slate-700' : 'bg-slate-900'}">
        Login
      </button>
      <button onclick={() => mode = 'register'}
        class="flex-1 py-2 text-sm {mode === 'register' ? 'bg-slate-700' : 'bg-slate-900'}">
        Register
      </button>
    </div>

    {#if mode === 'login'}
      <form method="POST" action="?/login" class="space-y-3">
        <input name="email" type="email" placeholder="Email" required
          class="w-full px-3 py-2 bg-slate-800 rounded border border-slate-700 text-sm" />
        <input name="password" type="password" placeholder="Password" required
          class="w-full px-3 py-2 bg-slate-800 rounded border border-slate-700 text-sm" />
        <button type="submit" class="w-full py-2 bg-cyan-600 hover:bg-cyan-500 rounded text-sm font-medium">
          Login
        </button>
      </form>
    {:else}
      <form method="POST" action="?/register" class="space-y-3">
        <input name="username" type="text" placeholder="Pilot name" required
          class="w-full px-3 py-2 bg-slate-800 rounded border border-slate-700 text-sm" />
        <input name="email" type="email" placeholder="Email" required
          class="w-full px-3 py-2 bg-slate-800 rounded border border-slate-700 text-sm" />
        <input name="password" type="password" placeholder="Password" required minlength="6"
          class="w-full px-3 py-2 bg-slate-800 rounded border border-slate-700 text-sm" />
        <button type="submit" class="w-full py-2 bg-cyan-600 hover:bg-cyan-500 rounded text-sm font-medium">
          Register
        </button>
      </form>
    {/if}

    <div class="relative flex items-center gap-2">
      <div class="flex-1 border-t border-slate-700"></div>
      <span class="text-slate-500 text-xs">or</span>
      <div class="flex-1 border-t border-slate-700"></div>
    </div>

    <form method="POST" action="?/guest">
      <button type="submit" class="w-full py-2 bg-slate-700 hover:bg-slate-600 rounded text-sm">
        Play as Guest
      </button>
    </form>
  </div>
</div>
```

**Step 3: Update home page to redirect**

Edit `src/routes/+page.svelte`:

```svelte
<script lang="ts">
  import { goto } from '$app/navigation';
  import { onMount } from 'svelte';
  let { data } = $props();
  onMount(() => {
    goto(data.user ? '/lobby' : '/auth');
  });
</script>
```

**Step 4: Verify auth flow manually**

```bash
npm run dev
```

Navigate to `/auth`, register, confirm redirect to `/lobby` (404 is fine — page not yet built).

**Step 5: Commit**

```bash
git add src/routes/auth/ src/routes/+page.svelte
git commit -m "feat: add auth UI with login, register, and guest flow"
```

---

## Task 5: Card Definitions — Seed Data & Admin Loader

**Files:**
- Create: `supabase/seed-cards.ts` (run with `npx tsx`)
- Create: `src/lib/cards.ts`
- Create: `src/lib/cards.test.ts`

**Step 1: Write tests for card validation logic**

Create `src/lib/cards.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { validateDeck, DECK_SIZE, MAX_COPIES, MAX_LEGENDARY, POINT_BUDGET } from './cards';

const makeCard = (id: string, rarity: string, cost: number, qty: number) =>
  ({ id, rarity, point_cost: cost, quantity: qty });

describe('validateDeck', () => {
  it('requires exactly 60 cards', () => {
    const cards = [makeCard('A', 'common', 1, 59)];
    expect(validateDeck(cards)).toContain('must contain exactly 60 cards');
  });

  it('rejects more than 4 copies of a card', () => {
    const cards = [makeCard('A', 'common', 1, 5)];
    expect(validateDeck(cards)).toContain('max 4 copies');
  });

  it('rejects more than 1 legendary', () => {
    const cards = [
      makeCard('LEG1', 'legendary', 10, 1),
      makeCard('LEG2', 'legendary', 10, 1),
      makeCard('FILL', 'common', 1, 58)
    ];
    expect(validateDeck(cards)).toContain('max 1 legendary');
  });

  it('rejects over 100 point budget', () => {
    const cards = [makeCard('A', 'epic', 10, 10), makeCard('B', 'common', 1, 50)];
    expect(validateDeck(cards)).toContain('100-point budget');
  });

  it('accepts a valid deck', () => {
    const cards = [makeCard('A', 'common', 1, 60)];
    expect(validateDeck(cards)).toBeNull();
  });
});
```

**Step 2: Run tests to verify they fail**

```bash
npm run test -- cards.test
```

Expected: FAIL — module not found.

**Step 3: Create src/lib/cards.ts**

```typescript
export const DECK_SIZE = 60;
export const MAX_COPIES = 4;
export const MAX_LEGENDARY = 1;
export const POINT_BUDGET = 100;

interface DeckEntry {
  id: string;
  rarity: string;
  point_cost: number;
  quantity: number;
}

export function validateDeck(cards: DeckEntry[]): string | null {
  const totalCards = cards.reduce((sum, c) => sum + c.quantity, 0);
  if (totalCards !== DECK_SIZE) return `Deck must contain exactly 60 cards (has ${totalCards})`;

  for (const card of cards) {
    if (card.quantity > MAX_COPIES) return `${card.id}: max 4 copies allowed`;
  }

  const legendaryCount = cards.filter(c => c.rarity === 'legendary').reduce((s, c) => s + c.quantity, 0);
  if (legendaryCount > MAX_LEGENDARY) return `Deck has max 1 legendary`;

  const totalPoints = cards.reduce((sum, c) => sum + c.point_cost * c.quantity, 0);
  if (totalPoints > POINT_BUDGET) return `Deck exceeds 100-point budget (${totalPoints} pts)`;

  return null;
}
```

**Step 4: Run tests to verify they pass**

```bash
npm run test -- cards.test
```

Expected: PASS.

**Step 5: Create starter card seed script**

Create `supabase/seed-cards.ts` (a small representative set to unblock development — expand to 200 at content-creation phase):

```typescript
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

const cards = [
  // --- FRAMES ---
  {
    id: '0301-REAPER',
    name: 'Reaper',
    type: 'frame',
    rarity: 'rare',
    point_cost: 6,
    stats: { parts: ['head','torso','left_arm','right_arm','left_leg','right_leg'], base_hp: { head:20,torso:40,left_arm:25,right_arm:25,left_leg:20,right_leg:20 }, base_ap: 3, slots: { head:1,torso:2,left_arm:2,right_arm:2,left_leg:1,right_leg:1 } },
    discard_effect: { description: 'Gain 1 AP this turn' },
    is_starter: false
  },
  {
    id: '0201-ATLAS-HVY',
    name: 'Atlas Heavy',
    type: 'frame',
    rarity: 'uncommon',
    point_cost: 4,
    stats: { parts: ['head','torso','left_arm','right_arm','left_leg','right_leg'], base_hp: { head:25,torso:60,left_arm:30,right_arm:30,left_leg:25,right_leg:25 }, base_ap: 2, slots: { head:1,torso:3,left_arm:1,right_arm:1,left_leg:1,right_leg:1 } },
    discard_effect: { description: 'Reduce next incoming damage by 5' },
    is_starter: true
  },
  // --- COMPONENTS ---
  {
    id: 'COMP-LASER-01',
    name: 'Pulse Laser',
    type: 'component',
    rarity: 'common',
    point_cost: 1,
    stats: { slot_type: 'weapon', damage: '2d6', energy_type: 'em', part_restriction: ['left_arm','right_arm'] },
    discard_effect: { description: 'Deal 3 EM damage to a random enemy part' },
    is_starter: true
  },
  {
    id: 'COMP-SHIELD-01',
    name: 'Basic Shield Generator',
    type: 'component',
    rarity: 'common',
    point_cost: 1,
    stats: { slot_type: 'shield', shield_points: 15, regen_per_upkeep: 5, resist_profile: { kinetic: 1.0, em: 1.5, thermal: 1.0 }, part_restriction: ['torso'] },
    discard_effect: { description: 'Restore 8 shield points immediately' },
    is_starter: true
  },
  {
    id: 'COMP-TARGET-01',
    name: 'Targeting Reticle',
    type: 'component',
    rarity: 'common',
    point_cost: 1,
    stats: { slot_type: 'targeting', part_restriction: ['head'] },
    discard_effect: { description: 'Your next attack ignores 3 armor' },
    is_starter: true
  },
  {
    id: 'COMP-HYDRAULIC-01',
    name: 'Hydraulic Actuator',
    type: 'component',
    rarity: 'common',
    point_cost: 1,
    stats: { slot_type: 'passive', effect: 'draw_bonus', amount: 1, part_restriction: ['left_leg','right_leg'] },
    discard_effect: { description: 'Draw 1 card immediately' },
    is_starter: true
  },
  // --- ACTIONS ---
  {
    id: 'ACT-OVERCHARGE-01',
    name: 'Overcharge',
    type: 'action',
    rarity: 'common',
    point_cost: 1,
    stats: { effect: 'gain_ap', amount: 2 },
    discard_effect: { description: 'Deal 2 thermal damage to self, gain 1 AP' },
    is_starter: true
  },
  {
    id: 'ACT-REPAIR-01',
    name: 'Field Repair',
    type: 'action',
    rarity: 'uncommon',
    point_cost: 2,
    stats: { effect: 'repair', amount: 10, target: 'self_any_part' },
    discard_effect: { description: 'Repair 4 HP to most damaged part' },
    is_starter: false
  },
  // --- ENERGY ---
  {
    id: 'NRG-CORE-01',
    name: 'Power Cell',
    type: 'energy',
    rarity: 'common',
    point_cost: 1,
    stats: { ap_grant: 1 },
    discard_effect: { description: 'Deal 2 EM damage and apply Jammed (1 turn)' },
    is_starter: true
  },
  // --- ARMOR ---
  {
    id: 'ARM-PLATE-01',
    name: 'Blast Plating',
    type: 'armor',
    rarity: 'common',
    point_cost: 1,
    stats: { armor_points: 8, part_restriction: 'any' },
    discard_effect: { description: 'Block up to 10 incoming damage once' },
    is_starter: true
  }
];

async function seed() {
  const { error } = await supabase.from('card_definitions').upsert(cards, { onConflict: 'id' });
  if (error) { console.error(error); process.exit(1); }
  console.log(`Seeded ${cards.length} cards.`);
}

seed();
```

**Step 6: Run card seed**

```bash
SUPABASE_URL=http://localhost:54321 SUPABASE_SERVICE_ROLE_KEY=<local-service-key> npx tsx supabase/seed-cards.ts
```

(Get local service key from `npx supabase status`.)

Expected: "Seeded 10 cards."

**Step 7: Commit**

```bash
git add src/lib/cards.ts src/lib/cards.test.ts supabase/seed-cards.ts
git commit -m "feat: add deck validation logic and starter card seed"
```

---

## Task 6: Deck Builder UI

**Files:**
- Create: `src/routes/decks/+page.svelte`
- Create: `src/routes/decks/+page.server.ts`
- Create: `src/routes/decks/[id]/+page.svelte`
- Create: `src/routes/decks/[id]/+page.server.ts`

**Step 1: Create deck list page server**

Create `src/routes/decks/+page.server.ts`:

```typescript
import { redirect } from '@sveltejs/kit';
import type { PageServerLoad, Actions } from './$types';

export const load: PageServerLoad = async ({ locals }) => {
  const { user } = await locals.safeGetSession();
  if (!user) redirect(303, '/auth');

  const { data: decks } = await locals.supabase
    .from('decks')
    .select('id, name, is_starter, created_at')
    .eq('user_id', user.id)
    .order('created_at', { ascending: false });

  return { decks: decks ?? [] };
};

export const actions: Actions = {
  create: async ({ locals }) => {
    const { user } = await locals.safeGetSession();
    if (!user) redirect(303, '/auth');

    const { data: deck, error } = await locals.supabase
      .from('decks')
      .insert({ user_id: user.id, name: 'New Deck' })
      .select('id')
      .single();

    if (error || !deck) return;
    redirect(303, `/decks/${deck.id}`);
  }
};
```

**Step 2: Create deck list page**

Create `src/routes/decks/+page.svelte`:

```svelte
<script lang="ts">
  import type { PageData } from './$types';
  let { data }: { data: PageData } = $props();
</script>

<div class="p-4 max-w-lg mx-auto space-y-4">
  <div class="flex items-center justify-between">
    <h1 class="text-xl font-bold">My Decks</h1>
    <form method="POST" action="?/create">
      <button type="submit" class="px-3 py-1 bg-cyan-600 hover:bg-cyan-500 rounded text-sm">+ New Deck</button>
    </form>
  </div>

  {#each data.decks as deck}
    <a href="/decks/{deck.id}" class="block p-3 bg-slate-800 rounded border border-slate-700 hover:border-cyan-600">
      <div class="font-medium">{deck.name}</div>
      {#if deck.is_starter}<span class="text-xs text-slate-400">Starter</span>{/if}
    </a>
  {:else}
    <p class="text-slate-400 text-sm">No decks yet. Create one to get started.</p>
  {/each}
</div>
```

**Step 3: Create deck editor page server**

Create `src/routes/decks/[id]/+page.server.ts`:

```typescript
import { redirect, fail } from '@sveltejs/kit';
import type { PageServerLoad, Actions } from './$types';
import { validateDeck } from '$lib/cards';

export const load: PageServerLoad = async ({ locals, params }) => {
  const { user } = await locals.safeGetSession();
  if (!user) redirect(303, '/auth');

  const [{ data: deck }, { data: allCards }, { data: deckCards }] = await Promise.all([
    locals.supabase.from('decks').select('*').eq('id', params.id).eq('user_id', user.id).single(),
    locals.supabase.from('card_definitions').select('*').order('type').order('name'),
    locals.supabase.from('deck_cards').select('card_id, quantity').eq('deck_id', params.id)
  ]);

  if (!deck) redirect(303, '/decks');

  return { deck, allCards: allCards ?? [], deckCards: deckCards ?? [] };
};

export const actions: Actions = {
  setCard: async ({ locals, params, request }) => {
    const { user } = await locals.safeGetSession();
    if (!user) redirect(303, '/auth');

    const form = await request.formData();
    const cardId = form.get('card_id') as string;
    const qty = parseInt(form.get('quantity') as string, 10);

    if (qty <= 0) {
      await locals.supabase.from('deck_cards').delete()
        .eq('deck_id', params.id).eq('card_id', cardId);
    } else {
      await locals.supabase.from('deck_cards').upsert(
        { deck_id: params.id, card_id: cardId, quantity: qty },
        { onConflict: 'deck_id,card_id' }
      );
    }
  },

  rename: async ({ locals, params, request }) => {
    const { user } = await locals.safeGetSession();
    if (!user) redirect(303, '/auth');
    const form = await request.formData();
    const name = form.get('name') as string;
    await locals.supabase.from('decks').update({ name }).eq('id', params.id).eq('user_id', user.id);
  },

  validate: async ({ locals, params }) => {
    const { data: deckCards } = await locals.supabase
      .from('deck_cards')
      .select('card_id, quantity, card_definitions(rarity, point_cost)')
      .eq('deck_id', params.id);

    const entries = (deckCards ?? []).map(dc => ({
      id: dc.card_id,
      rarity: (dc.card_definitions as any).rarity,
      point_cost: (dc.card_definitions as any).point_cost,
      quantity: dc.quantity
    }));

    const error = validateDeck(entries);
    if (error) return fail(400, { validationError: error });
    return { valid: true };
  }
};
```

**Step 4: Create deck editor UI**

Create `src/routes/decks/[id]/+page.svelte`:

```svelte
<script lang="ts">
  import type { PageData, ActionData } from './$types';
  let { data, form }: { data: PageData; form: ActionData } = $props();

  const deckMap = $derived(new Map(data.deckCards.map(dc => [dc.card_id, dc.quantity])));
  const totalCards = $derived([...deckMap.values()].reduce((s, v) => s + v, 0));
</script>

<div class="p-4 max-w-lg mx-auto space-y-4">
  <div class="flex items-center gap-2">
    <a href="/decks" class="text-slate-400 text-sm">← Decks</a>
    <form method="POST" action="?/rename" class="flex-1 flex gap-2">
      <input name="name" value={data.deck.name}
        class="flex-1 bg-transparent border-b border-slate-600 focus:border-cyan-500 outline-none text-lg font-bold" />
      <button type="submit" class="text-xs text-slate-400 hover:text-white">Save</button>
    </form>
  </div>

  <div class="flex items-center justify-between text-sm">
    <span class="text-slate-400">{totalCards}/60 cards</span>
    <form method="POST" action="?/validate">
      <button type="submit" class="px-3 py-1 bg-slate-700 hover:bg-slate-600 rounded">Validate</button>
    </form>
  </div>

  {#if form?.validationError}
    <p class="text-red-400 text-sm">{form.validationError}</p>
  {:else if form?.valid}
    <p class="text-green-400 text-sm">Deck is valid!</p>
  {/if}

  {#each ['frame','component','action','energy','armor'] as cardType}
    <div>
      <h2 class="text-xs uppercase tracking-wider text-slate-400 mb-2">{cardType}s</h2>
      <div class="space-y-1">
        {#each data.allCards.filter(c => c.type === cardType) as card}
          {@const qty = deckMap.get(card.id) ?? 0}
          <div class="flex items-center gap-2 p-2 bg-slate-800 rounded text-sm">
            <span class="flex-1">{card.name}</span>
            <span class="text-slate-500">{card.point_cost}pt</span>
            <form method="POST" action="?/setCard" class="flex items-center gap-1">
              <input type="hidden" name="card_id" value={card.id} />
              <button type="submit" name="quantity" value={qty - 1}
                class="w-6 h-6 bg-slate-700 rounded text-center hover:bg-slate-600">-</button>
              <span class="w-4 text-center">{qty}</span>
              <button type="submit" name="quantity" value={qty + 1}
                class="w-6 h-6 bg-slate-700 rounded text-center hover:bg-slate-600">+</button>
            </form>
          </div>
        {/each}
      </div>
    </div>
  {/each}
</div>
```

**Step 5: Verify deck builder manually**

```bash
npm run dev
```

Navigate to `/decks`, create a deck, add/remove cards, validate.

**Step 6: Commit**

```bash
git add src/routes/decks/
git commit -m "feat: add deck list and deck editor UI"
```

---

## Task 7: Lobby — Create, Join, Ready

**Files:**
- Create: `src/routes/lobby/+page.svelte`
- Create: `src/routes/lobby/+page.server.ts`
- Create: `supabase/functions/create-room/index.ts`
- Create: `supabase/functions/join-room/index.ts`
- Create: `supabase/functions/set-ready/index.ts`

**Step 1: Create Edge Function — create-room**

Create `supabase/functions/create-room/index.ts`:

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

Deno.serve(async (req) => {
  const supabase = createClient(
    Deno.env.get('SUPABASE_URL')!,
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
    { global: { headers: { Authorization: req.headers.get('Authorization')! } } }
  );

  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 });

  const { max_players = 4, deck_id } = await req.json();

  // Generate unique 6-char room code
  let room_code = '';
  let attempts = 0;
  while (attempts < 10) {
    room_code = Math.random().toString(36).slice(2, 8).toUpperCase();
    const { data } = await supabase.from('game_rooms').select('id').eq('room_code', room_code).maybeSingle();
    if (!data) break;
    attempts++;
  }

  const { data: room, error } = await supabase
    .from('game_rooms')
    .insert({ room_code, max_players, host_id: user.id })
    .select('id, room_code')
    .single();

  if (error) return new Response(JSON.stringify({ error: error.message }), { status: 500 });

  // Add host as first player
  await supabase.from('game_players').insert({
    room_id: room.id, user_id: user.id, deck_id, seat_order: 0
  });

  return new Response(JSON.stringify(room), { headers: { 'Content-Type': 'application/json' } });
});
```

**Step 2: Create Edge Function — join-room**

Create `supabase/functions/join-room/index.ts`:

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

Deno.serve(async (req) => {
  const supabase = createClient(
    Deno.env.get('SUPABASE_URL')!,
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
    { global: { headers: { Authorization: req.headers.get('Authorization')! } } }
  );

  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 });

  const { room_code, deck_id } = await req.json();

  const { data: room } = await supabase
    .from('game_rooms')
    .select('id, max_players, status')
    .eq('room_code', room_code.toUpperCase())
    .single();

  if (!room) return new Response(JSON.stringify({ error: 'Room not found' }), { status: 404 });
  if (room.status !== 'pending') return new Response(JSON.stringify({ error: 'Game already started' }), { status: 409 });

  const { count } = await supabase
    .from('game_players')
    .select('*', { count: 'exact', head: true })
    .eq('room_id', room.id);

  if ((count ?? 0) >= room.max_players) {
    return new Response(JSON.stringify({ error: 'Room is full' }), { status: 409 });
  }

  await supabase.from('game_players').upsert(
    { room_id: room.id, user_id: user.id, deck_id, seat_order: count },
    { onConflict: 'room_id,user_id' }
  );

  return new Response(JSON.stringify({ room_id: room.id }), { headers: { 'Content-Type': 'application/json' } });
});
```

**Step 3: Create Edge Function — set-ready**

Create `supabase/functions/set-ready/index.ts`:

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { initGameState } from '../_shared/game-engine.ts';

Deno.serve(async (req) => {
  const supabase = createClient(
    Deno.env.get('SUPABASE_URL')!,
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
    { global: { headers: { Authorization: req.headers.get('Authorization')! } } }
  );

  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 });

  const { room_id } = await req.json();

  await supabase.from('game_players')
    .update({ is_ready: true })
    .eq('room_id', room_id)
    .eq('user_id', user.id);

  // Check if all players are ready
  const { data: players } = await supabase
    .from('game_players')
    .select('user_id, is_ready, deck_id')
    .eq('room_id', room_id);

  const allReady = players?.every(p => p.is_ready) && (players?.length ?? 0) >= 2;

  if (allReady) {
    const { data: room } = await supabase.from('game_rooms').select('host_id').eq('id', room_id).single();
    if (room?.host_id === user.id) {
      // Host triggers game start
      const state = await initGameState(supabase, room_id, players!);
      await supabase.from('game_rooms').update({ status: 'in_progress' }).eq('id', room_id);
      await supabase.from('game_state').insert({ room_id, state, phase: 'upkeep', turn_number: 1, active_player_id: players![0].user_id });
    }
  }

  return new Response(JSON.stringify({ ok: true }), { headers: { 'Content-Type': 'application/json' } });
});
```

**Step 4: Create lobby page server**

Create `src/routes/lobby/+page.server.ts`:

```typescript
import { redirect } from '@sveltejs/kit';
import type { PageServerLoad } from './$types';

export const load: PageServerLoad = async ({ locals }) => {
  const { user } = await locals.safeGetSession();
  if (!user) redirect(303, '/auth');

  const { data: decks } = await locals.supabase
    .from('decks')
    .select('id, name')
    .eq('user_id', user.id);

  return { decks: decks ?? [], user };
};
```

**Step 5: Create lobby page UI**

Create `src/routes/lobby/+page.svelte`:

```svelte
<script lang="ts">
  import { createClient } from '$lib/supabase';
  import type { PageData } from './$types';
  let { data }: { data: PageData } = $props();

  const supabase = createClient();
  let selectedDeckId = $state(data.decks[0]?.id ?? '');
  let joinCode = $state('');
  let error = $state('');
  let loading = $state(false);

  async function callEdge(fn: string, body: object) {
    const { data: { session } } = await supabase.auth.getSession();
    const res = await fetch(`${import.meta.env.PUBLIC_SUPABASE_URL}/functions/v1/${fn}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${session?.access_token}`
      },
      body: JSON.stringify(body)
    });
    return res.json();
  }

  async function createRoom() {
    loading = true; error = '';
    const result = await callEdge('create-room', { max_players: 4, deck_id: selectedDeckId });
    if (result.error) { error = result.error; loading = false; return; }
    window.location.href = `/room/${result.id}`;
  }

  async function joinRoom() {
    loading = true; error = '';
    const result = await callEdge('join-room', { room_code: joinCode, deck_id: selectedDeckId });
    if (result.error) { error = result.error; loading = false; return; }
    window.location.href = `/room/${result.room_id}`;
  }
</script>

<div class="p-4 max-w-sm mx-auto space-y-6">
  <div class="flex justify-between items-center">
    <h1 class="text-xl font-bold">Lobby</h1>
    <a href="/decks" class="text-sm text-cyan-400">My Decks</a>
  </div>

  <div>
    <label class="block text-sm text-slate-400 mb-1">Select Deck</label>
    <select bind:value={selectedDeckId} class="w-full bg-slate-800 border border-slate-700 rounded px-3 py-2 text-sm">
      {#each data.decks as deck}
        <option value={deck.id}>{deck.name}</option>
      {:else}
        <option disabled>No decks — create one first</option>
      {/each}
    </select>
  </div>

  {#if error}
    <p class="text-red-400 text-sm">{error}</p>
  {/if}

  <button onclick={createRoom} disabled={loading || !selectedDeckId}
    class="w-full py-3 bg-cyan-600 hover:bg-cyan-500 disabled:opacity-50 rounded font-medium">
    Create Room
  </button>

  <div class="relative flex items-center gap-2">
    <div class="flex-1 border-t border-slate-700"></div>
    <span class="text-slate-500 text-xs">or join</span>
    <div class="flex-1 border-t border-slate-700"></div>
  </div>

  <div class="flex gap-2">
    <input bind:value={joinCode} placeholder="Room code" maxlength="6"
      class="flex-1 bg-slate-800 border border-slate-700 rounded px-3 py-2 text-sm uppercase tracking-widest" />
    <button onclick={joinRoom} disabled={loading || joinCode.length < 6 || !selectedDeckId}
      class="px-4 py-2 bg-slate-700 hover:bg-slate-600 disabled:opacity-50 rounded text-sm">
      Join
    </button>
  </div>
</div>
```

**Step 6: Deploy Edge Functions locally**

```bash
npx supabase functions serve
```

Expected: functions served at localhost:54321/functions/v1/.

**Step 7: Test create room**

```bash
curl -X POST http://localhost:54321/functions/v1/create-room \
  -H "Authorization: Bearer <user-jwt>" \
  -H "Content-Type: application/json" \
  -d '{"max_players": 2}'
```

Expected: `{ "id": "...", "room_code": "ABC123" }`

**Step 8: Commit**

```bash
git add src/routes/lobby/ supabase/functions/create-room/ supabase/functions/join-room/ supabase/functions/set-ready/
git commit -m "feat: add lobby UI and create-room/join-room/set-ready edge functions"
```

---

## Task 8: Game Engine — Shared Types & State Init

**Files:**
- Create: `supabase/functions/_shared/types.ts`
- Create: `supabase/functions/_shared/game-engine.ts`
- Create: `supabase/functions/_shared/game-engine.test.ts`

**Step 1: Define shared game types**

Create `supabase/functions/_shared/types.ts`:

```typescript
export type Phase = 'upkeep' | 'build' | 'combat' | 'end';
export type StatusEffect = 'burning' | 'empd' | 'stunned' | 'overheated' | 'jammed' | 'corroded' | 'disrupted' | 'marked' | 'shielded' | 'energized' | 'repairing';
export type PartName = 'head' | 'torso' | 'left_arm' | 'right_arm' | 'left_leg' | 'right_leg';

export interface PartState {
  name: PartName;
  hp: number;
  max_hp: number;
  armor: number;
  installed_components: ComponentState[];
  status_effects: { effect: StatusEffect; turns_remaining: number }[];
}

export interface ComponentState {
  card_id: string;
  hp: number;
  max_hp: number;
  is_active: boolean;
}

export interface ShieldState {
  sp: number;
  max_sp: number;
  regen: number;
  resist_profile: Record<string, number>;
}

export interface PlayerState {
  user_id: string;
  frame_card_id: string;
  parts: Record<PartName, PartState>;
  shield: ShieldState | null;
  ap: number;
  ap_per_turn: number;
  hand: string[];      // card_ids
  deck: string[];      // card_ids (shuffled)
  discard: string[];
  reshuffle_count: number;
  status_effects: { effect: StatusEffect; turns_remaining: number }[];
  is_eliminated: boolean;
  targeting_system: boolean;
}

export interface GameState {
  players: Record<string, PlayerState>;  // keyed by user_id
  turn_order: string[];                  // user_id[]
  phase: Phase;
  turn_number: number;
  active_player_id: string;
  log: string[];
}
```

**Step 2: Write tests for initGameState**

Create `supabase/functions/_shared/game-engine.test.ts` (run with Deno test):

```typescript
import { assertEquals } from 'https://deno.land/std/assert/mod.ts';
import { buildPlayerState } from './game-engine.ts';

Deno.test('buildPlayerState sets correct base HP from frame stats', () => {
  const frameCard = {
    id: '0201-ATLAS-HVY',
    stats: {
      base_hp: { head: 25, torso: 60, left_arm: 30, right_arm: 30, left_leg: 25, right_leg: 25 },
      base_ap: 2,
      slots: { head: 1, torso: 3, left_arm: 1, right_arm: 1, left_leg: 1, right_leg: 1 }
    }
  };
  const state = buildPlayerState('user-1', frameCard, []);
  assertEquals(state.parts.torso.max_hp, 60);
  assertEquals(state.ap_per_turn, 2);
});

Deno.test('buildPlayerState shuffles and deals 5 cards to hand', () => {
  const frameCard = {
    id: '0201-ATLAS-HVY',
    stats: { base_hp: { head:25,torso:60,left_arm:30,right_arm:30,left_leg:25,right_leg:25 }, base_ap:2, slots:{} }
  };
  const deck = ['C1','C2','C3','C4','C5','C6','C7','C8','C9','C10'];
  const state = buildPlayerState('user-1', frameCard, deck);
  assertEquals(state.hand.length, 5);
  assertEquals(state.deck.length, 5);
});
```

**Step 3: Run tests to verify they fail**

```bash
deno test supabase/functions/_shared/game-engine.test.ts
```

Expected: FAIL — module not found.

**Step 4: Implement game-engine.ts**

Create `supabase/functions/_shared/game-engine.ts`:

```typescript
import type { GameState, PlayerState, PartName, PartState } from './types.ts';

const PART_NAMES: PartName[] = ['head','torso','left_arm','right_arm','left_leg','right_leg'];
const INITIAL_HAND_SIZE = 5;

export function buildPlayerState(userId: string, frameCard: any, deckCardIds: string[]): PlayerState {
  const shuffled = [...deckCardIds].sort(() => Math.random() - 0.5);
  const hand = shuffled.splice(0, INITIAL_HAND_SIZE);

  const parts = {} as Record<PartName, PartState>;
  for (const part of PART_NAMES) {
    const hp = frameCard.stats.base_hp[part] ?? 20;
    parts[part] = { name: part, hp, max_hp: hp, armor: 0, installed_components: [], status_effects: [] };
  }

  return {
    user_id: userId,
    frame_card_id: frameCard.id,
    parts,
    shield: null,
    ap: frameCard.stats.base_ap,
    ap_per_turn: frameCard.stats.base_ap,
    hand,
    deck: shuffled,
    discard: [],
    reshuffle_count: 0,
    status_effects: [],
    is_eliminated: false,
    targeting_system: false
  };
}

export async function initGameState(supabase: any, roomId: string, players: any[]): Promise<GameState> {
  const gameState: GameState = {
    players: {},
    turn_order: [],
    phase: 'upkeep',
    turn_number: 1,
    active_player_id: players[0].user_id,
    log: ['Game started!']
  };

  for (const player of players) {
    // Fetch their deck's card IDs
    const { data: deckCards } = await supabase
      .from('deck_cards')
      .select('card_id, quantity, card_definitions(stats, type)')
      .eq('deck_id', player.deck_id);

    // Expand deck (quantity copies each)
    const deckCardIds: string[] = [];
    let frameCard: any = null;
    for (const dc of deckCards ?? []) {
      if ((dc.card_definitions as any).type === 'frame' && !frameCard) {
        frameCard = { id: dc.card_id, stats: (dc.card_definitions as any).stats };
      }
      for (let i = 0; i < dc.quantity; i++) deckCardIds.push(dc.card_id);
    }

    if (!frameCard) continue; // skip invalid decks
    gameState.players[player.user_id] = buildPlayerState(player.user_id, frameCard, deckCardIds);
    gameState.turn_order.push(player.user_id);
  }

  return gameState;
}
```

**Step 5: Run tests to verify they pass**

```bash
deno test supabase/functions/_shared/game-engine.test.ts
```

Expected: PASS.

**Step 6: Commit**

```bash
git add supabase/functions/_shared/
git commit -m "feat: add shared game engine types and state initialization"
```

---

## Task 9: Game Engine — Turn Loop & Combat Edge Functions

**Files:**
- Modify: `supabase/functions/_shared/game-engine.ts`
- Create: `supabase/functions/_shared/damage.ts`
- Create: `supabase/functions/_shared/damage.test.ts`
- Create: `supabase/functions/play-card/index.ts`
- Create: `supabase/functions/attack/index.ts`
- Create: `supabase/functions/end-turn/index.ts`
- Create: `supabase/functions/discard-card/index.ts`

**Step 1: Write damage resolution tests**

Create `supabase/functions/_shared/damage.test.ts`:

```typescript
import { assertEquals } from 'https://deno.land/std/assert/mod.ts';
import { resolveDamage } from './damage.ts';
import type { PlayerState, PartName } from './types.ts';

function makePlayer(torsoHp: number, torsoArmor: number, shieldSp: number | null): PlayerState {
  const parts: any = {};
  for (const p of ['head','torso','left_arm','right_arm','left_leg','right_leg']) {
    parts[p] = { name: p, hp: p === 'torso' ? torsoHp : 20, max_hp: p === 'torso' ? torsoHp : 20, armor: p === 'torso' ? torsoArmor : 0, installed_components: [], status_effects: [] };
  }
  return {
    user_id: 'target', frame_card_id: 'X', parts, shield: shieldSp !== null ? { sp: shieldSp, max_sp: 20, regen: 5, resist_profile: {} } : null,
    ap: 3, ap_per_turn: 3, hand: [], deck: [], discard: [], reshuffle_count: 0, status_effects: [], is_eliminated: false, targeting_system: false
  };
}

Deno.test('damage hits shield first, overflow hits HP', () => {
  const player = makePlayer(40, 0, 10);
  const result = resolveDamage(player, 15, 'torso', 'kinetic');
  assertEquals(result.shieldDamage, 10);
  assertEquals(result.partHpDamage, 5);
  assertEquals(result.targetState.shield!.sp, 0);
  assertEquals(result.targetState.parts.torso.hp, 35);
});

Deno.test('armor absorbs damage before part HP', () => {
  const player = makePlayer(40, 8, null);
  const result = resolveDamage(player, 12, 'torso', 'kinetic');
  assertEquals(result.armorDamage, 8);
  assertEquals(result.partHpDamage, 4);
  assertEquals(result.targetState.parts.torso.armor, 0);
  assertEquals(result.targetState.parts.torso.hp, 36);
});

Deno.test('no damage when fully shielded', () => {
  const player = makePlayer(40, 0, 30);
  const result = resolveDamage(player, 10, 'torso', 'kinetic');
  assertEquals(result.partHpDamage, 0);
  assertEquals(result.targetState.parts.torso.hp, 40);
});
```

**Step 2: Run tests to verify they fail**

```bash
deno test supabase/functions/_shared/damage.test.ts
```

Expected: FAIL — module not found.

**Step 3: Implement damage resolution**

Create `supabase/functions/_shared/damage.ts`:

```typescript
import type { PlayerState, PartName } from './types.ts';

interface DamageResult {
  targetState: PlayerState;
  shieldDamage: number;
  armorDamage: number;
  partHpDamage: number;
  componentDestroyed: string | null;
  eliminated: boolean;
}

export function resolveDamage(
  player: PlayerState,
  rawDamage: number,
  targetPart: PartName,
  energyType: string
): DamageResult {
  const state = structuredClone(player);
  let remaining = rawDamage;
  let shieldDamage = 0, armorDamage = 0, partHpDamage = 0;
  let componentDestroyed: string | null = null;

  // 1. Shields
  if (state.shield && state.shield.sp > 0) {
    const resist = state.shield.resist_profile[energyType] ?? 1.0;
    const effectiveDamage = Math.round(remaining * resist);
    const absorbed = Math.min(state.shield.sp, effectiveDamage);
    shieldDamage = absorbed;
    state.shield.sp -= absorbed;
    remaining = Math.max(0, effectiveDamage - absorbed);
  }

  if (remaining <= 0) return { targetState: state, shieldDamage, armorDamage, partHpDamage, componentDestroyed, eliminated: false };

  const part = state.parts[targetPart];

  // 2. Part armor
  if (part.armor > 0) {
    const absorbed = Math.min(part.armor, remaining);
    armorDamage = absorbed;
    part.armor -= absorbed;
    remaining -= absorbed;
  }

  if (remaining <= 0) return { targetState: state, shieldDamage, armorDamage, partHpDamage, componentDestroyed, eliminated: false };

  // 3. Components absorb overflow before part HP
  for (const comp of part.installed_components) {
    if (!comp.is_active) continue;
    if (comp.hp >= remaining) {
      comp.hp -= remaining;
      remaining = 0;
      if (comp.hp <= 0) { comp.is_active = false; componentDestroyed = comp.card_id; }
      break;
    } else {
      remaining -= comp.hp;
      comp.hp = 0;
      comp.is_active = false;
      componentDestroyed = comp.card_id;
    }
  }

  // 4. Part HP
  if (remaining > 0) {
    partHpDamage = remaining;
    part.hp = Math.max(0, part.hp - remaining);
  }

  // 5. Elimination check
  const totalHp = Object.values(state.parts).reduce((s, p) => s + p.hp, 0);
  if (totalHp <= 0) state.is_eliminated = true;

  return { targetState: state, shieldDamage, armorDamage, partHpDamage, componentDestroyed, eliminated: state.is_eliminated };
}

export function rollDice(notation: string): number {
  // e.g. "4d6" → roll 4 six-sided dice
  const match = notation.match(/^(\d+)d(\d+)$/);
  if (!match) return parseInt(notation, 10);
  const count = parseInt(match[1], 10);
  const sides = parseInt(match[2], 10);
  let total = 0;
  for (let i = 0; i < count; i++) total += Math.floor(Math.random() * sides) + 1;
  return total;
}
```

**Step 4: Run tests to verify they pass**

```bash
deno test supabase/functions/_shared/damage.test.ts
```

Expected: PASS.

**Step 5: Add upkeep and end-turn helpers to game-engine.ts**

Add these exports to `supabase/functions/_shared/game-engine.ts`:

```typescript
export function applyUpkeep(state: GameState): GameState {
  const s = structuredClone(state);
  const player = s.players[s.active_player_id];

  // Draw 2 cards
  for (let i = 0; i < 2; i++) {
    if (player.deck.length === 0) {
      player.deck = [...player.discard].sort(() => Math.random() - 0.5);
      player.discard = [];
      player.reshuffle_count += 1;
      // 5 damage per reshuffle
      const torso = player.parts.torso;
      torso.hp = Math.max(0, torso.hp - 5);
    }
    if (player.deck.length > 0) player.hand.push(player.deck.shift()!);
  }

  // Shield regen
  if (player.shield) {
    player.shield.sp = Math.min(player.shield.max_sp, player.shield.sp + player.shield.regen);
  }

  // Status effect ticks
  player.status_effects = player.status_effects
    .map(se => ({ ...se, turns_remaining: se.turns_remaining - 1 }))
    .filter(se => se.turns_remaining > 0);

  // Burning damage
  const burning = player.status_effects.find(se => se.effect === 'burning');
  if (burning) {
    const torso = player.parts.torso;
    torso.hp = Math.max(0, torso.hp - 3);
  }

  // Leg passive bonuses
  for (const legPart of ['left_leg', 'right_leg'] as const) {
    for (const comp of player.parts[legPart].installed_components) {
      if (!comp.is_active) continue;
      // These are resolved by card stats — handled in play-card for install;
      // here we just handle the upkeep trigger if marked as passive
    }
  }

  // Restore AP
  let apBonus = 0;
  const stunned = player.status_effects.find(se => se.effect === 'stunned');
  if (stunned) apBonus -= 1; // stun reduces AP next turn (resolved at upkeep of that turn)
  player.ap = Math.max(0, player.ap_per_turn + apBonus);

  s.phase = 'build';
  s.log.push(`Upkeep: ${player.user_id} draws 2 cards, AP restored to ${player.ap}`);
  return s;
}

export function advanceTurn(state: GameState): GameState {
  const s = structuredClone(state);
  // Discard to 7
  const player = s.players[s.active_player_id];
  while (player.hand.length > 7) player.discard.push(player.hand.pop()!);

  // Next living player
  const living = s.turn_order.filter(uid => !s.players[uid].is_eliminated);
  const idx = living.indexOf(s.active_player_id);
  s.active_player_id = living[(idx + 1) % living.length];
  s.turn_number += 1;
  s.phase = 'upkeep';
  s.log.push(`Turn ${s.turn_number} — ${s.active_player_id}'s turn`);
  return s;
}
```

**Step 6: Create play-card Edge Function**

Create `supabase/functions/play-card/index.ts`:

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import type { GameState } from '../_shared/types.ts';

Deno.serve(async (req) => {
  const supabase = createClient(Deno.env.get('SUPABASE_URL')!, Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
    { global: { headers: { Authorization: req.headers.get('Authorization')! } } });

  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 });

  const { room_id, card_id, target_part, install_part } = await req.json();

  const { data: gs } = await supabase.from('game_state').select('*').eq('room_id', room_id).single();
  if (!gs) return new Response(JSON.stringify({ error: 'Game not found' }), { status: 404 });

  const state: GameState = gs.state;
  if (state.active_player_id !== user.id) return new Response(JSON.stringify({ error: 'Not your turn' }), { status: 403 });
  if (state.phase !== 'build') return new Response(JSON.stringify({ error: 'Not build phase' }), { status: 400 });

  const player = state.players[user.id];
  const cardIdx = player.hand.indexOf(card_id);
  if (cardIdx === -1) return new Response(JSON.stringify({ error: 'Card not in hand' }), { status: 400 });

  // Fetch card definition
  const { data: cardDef } = await supabase.from('card_definitions').select('*').eq('id', card_id).single();
  if (!cardDef) return new Response(JSON.stringify({ error: 'Unknown card' }), { status: 400 });

  // Remove from hand
  player.hand.splice(cardIdx, 1);

  if (cardDef.type === 'frame') {
    // Swap active frame — rebuild parts from new frame stats (keep installed components)
    player.frame_card_id = card_id;
    player.ap_per_turn = cardDef.stats.base_ap;
    player.discard.push(card_id);
  } else if (cardDef.type === 'component' && install_part) {
    const part = player.parts[install_part as keyof typeof player.parts];
    part.installed_components.push({ card_id, hp: 20, max_hp: 20, is_active: true });
    // Handle targeting system
    if (cardDef.stats.slot_type === 'targeting') player.targeting_system = true;
    // Handle shield generator
    if (cardDef.stats.slot_type === 'shield') {
      player.shield = { sp: cardDef.stats.shield_points, max_sp: cardDef.stats.shield_points, regen: cardDef.stats.regen_per_upkeep, resist_profile: cardDef.stats.resist_profile ?? {} };
    }
  } else if (cardDef.type === 'energy') {
    player.ap += cardDef.stats.ap_grant ?? 1;
    player.discard.push(card_id);
  } else if (cardDef.type === 'armor' && install_part) {
    const part = player.parts[install_part as keyof typeof player.parts];
    part.armor += cardDef.stats.armor_points ?? 0;
    player.discard.push(card_id);
  } else if (cardDef.type === 'action') {
    // Action effects handled here — simplified for now
    player.discard.push(card_id);
  }

  // Cost 1 AP to play a card
  player.ap = Math.max(0, player.ap - 1);
  state.log.push(`${user.id} played ${cardDef.name}`);

  await supabase.from('game_state').update({ state, updated_at: new Date().toISOString() }).eq('room_id', room_id);
  return new Response(JSON.stringify({ ok: true }), { headers: { 'Content-Type': 'application/json' } });
});
```

**Step 7: Create attack Edge Function**

Create `supabase/functions/attack/index.ts`:

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { resolveDamage, rollDice } from '../_shared/damage.ts';
import type { GameState, PartName } from '../_shared/types.ts';

Deno.serve(async (req) => {
  const supabase = createClient(Deno.env.get('SUPABASE_URL')!, Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
    { global: { headers: { Authorization: req.headers.get('Authorization')! } } });

  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 });

  const { room_id, weapon_card_id, target_user_id, target_part } = await req.json();

  const { data: gs } = await supabase.from('game_state').select('*').eq('room_id', room_id).single();
  if (!gs) return new Response(JSON.stringify({ error: 'Game not found' }), { status: 404 });

  const state: GameState = gs.state;
  if (state.active_player_id !== user.id) return new Response(JSON.stringify({ error: 'Not your turn' }), { status: 403 });
  if (state.phase !== 'combat') return new Response(JSON.stringify({ error: 'Not combat phase' }), { status: 400 });

  const attacker = state.players[user.id];
  if (attacker.ap < 1) return new Response(JSON.stringify({ error: 'No AP' }), { status: 400 });

  // Find the weapon in installed components
  let weaponStats: any = null;
  outer: for (const part of Object.values(attacker.parts)) {
    for (const comp of part.installed_components) {
      if (comp.card_id === weapon_card_id && comp.is_active) {
        const { data: cd } = await supabase.from('card_definitions').select('stats').eq('id', weapon_card_id).single();
        weaponStats = cd?.stats;
        break outer;
      }
    }
  }
  if (!weaponStats) return new Response(JSON.stringify({ error: 'Weapon not found or not active' }), { status: 400 });

  // Determine target part
  let resolvedPart: PartName = target_part;
  if (!attacker.targeting_system || attacker.status_effects.some(se => se.effect === 'jammed')) {
    // Random part
    const parts: PartName[] = ['head','torso','left_arm','right_arm','left_leg','right_leg'];
    resolvedPart = parts[Math.floor(Math.random() * parts.length)];
  }

  // Weapon overclock check
  let damage = rollDice(weaponStats.damage);
  const overclock = attacker.status_effects.find(se => se.effect === 'energized');
  if (overclock) damage = Math.round(damage * 1.2);

  // Marked check on target
  const targetPlayer = state.players[target_user_id];
  if (!targetPlayer || targetPlayer.is_eliminated) return new Response(JSON.stringify({ error: 'Invalid target' }), { status: 400 });
  if (targetPlayer.status_effects.some(se => se.effect === 'marked')) damage = Math.round(damage * 1.2);

  const result = resolveDamage(targetPlayer, damage, resolvedPart, weaponStats.energy_type ?? 'kinetic');
  state.players[target_user_id] = result.targetState;
  attacker.ap -= 1;
  state.log.push(`${user.id} fired ${weapon_card_id} at ${target_user_id}:${resolvedPart} for ${damage} damage`);

  // Elimination
  if (result.eliminated) {
    state.log.push(`${target_user_id} has been eliminated!`);
    // Salvage Rights are handled by separate 'salvage' function call
  }

  await supabase.from('game_state').update({ state, updated_at: new Date().toISOString() }).eq('room_id', room_id);
  return new Response(JSON.stringify({ damage, targetPart: resolvedPart, eliminated: result.eliminated }), { headers: { 'Content-Type': 'application/json' } });
});
```

**Step 8: Create end-turn Edge Function**

Create `supabase/functions/end-turn/index.ts`:

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { advanceTurn, applyUpkeep } from '../_shared/game-engine.ts';
import type { GameState } from '../_shared/types.ts';

Deno.serve(async (req) => {
  const supabase = createClient(Deno.env.get('SUPABASE_URL')!, Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
    { global: { headers: { Authorization: req.headers.get('Authorization')! } } });

  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 });

  const { room_id } = await req.json();

  const { data: gs } = await supabase.from('game_state').select('*').eq('room_id', room_id).single();
  if (!gs) return new Response(JSON.stringify({ error: 'Game not found' }), { status: 404 });

  let state: GameState = gs.state;
  if (state.active_player_id !== user.id) return new Response(JSON.stringify({ error: 'Not your turn' }), { status: 403 });

  // Check if only one player remains
  const living = state.turn_order.filter(uid => !state.players[uid].is_eliminated);
  if (living.length === 1) {
    // Game over
    await supabase.from('game_rooms').update({ status: 'completed' }).eq('id', room_id);
    await supabase.from('match_history').insert({ room_id, winner_id: living[0] });
    state.log.push(`Game over! Winner: ${living[0]}`);
    await supabase.from('game_state').update({ state, phase: 'end', updated_at: new Date().toISOString() }).eq('room_id', room_id);
    return new Response(JSON.stringify({ game_over: true, winner: living[0] }), { headers: { 'Content-Type': 'application/json' } });
  }

  state = advanceTurn(state);
  state = applyUpkeep(state);

  await supabase.from('game_state').update({ state, phase: state.phase, turn_number: state.turn_number, active_player_id: state.active_player_id, updated_at: new Date().toISOString() }).eq('room_id', room_id);
  return new Response(JSON.stringify({ ok: true }), { headers: { 'Content-Type': 'application/json' } });
});
```

**Step 9: Create discard-card Edge Function**

Create `supabase/functions/discard-card/index.ts`:

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import type { GameState } from '../_shared/types.ts';

Deno.serve(async (req) => {
  const supabase = createClient(Deno.env.get('SUPABASE_URL')!, Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
    { global: { headers: { Authorization: req.headers.get('Authorization')! } } });

  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 });

  const { room_id, card_id } = await req.json();

  const { data: gs } = await supabase.from('game_state').select('*').eq('room_id', room_id).single();
  const state: GameState = gs?.state;
  if (!state) return new Response(JSON.stringify({ error: 'Game not found' }), { status: 404 });
  if (state.active_player_id !== user.id) return new Response(JSON.stringify({ error: 'Not your turn' }), { status: 403 });

  const player = state.players[user.id];
  const idx = player.hand.indexOf(card_id);
  if (idx === -1) return new Response(JSON.stringify({ error: 'Card not in hand' }), { status: 400 });

  // Fetch card's discard effect
  const { data: cardDef } = await supabase.from('card_definitions').select('discard_effect, name').eq('id', card_id).single();
  player.hand.splice(idx, 1);
  player.discard.push(card_id);

  // Apply discard effect — simplified: just log for now; full implementation per card type in next task
  state.log.push(`${user.id} discarded ${cardDef?.name} for its effect`);

  await supabase.from('game_state').update({ state, updated_at: new Date().toISOString() }).eq('room_id', room_id);
  return new Response(JSON.stringify({ ok: true, effect: cardDef?.discard_effect }), { headers: { 'Content-Type': 'application/json' } });
});
```

**Step 10: Commit**

```bash
git add supabase/functions/
git commit -m "feat: add combat edge functions (play-card, attack, end-turn, discard-card)"
```

---

## Task 10: Room Waiting Screen & Realtime Game Sync

**Files:**
- Create: `src/routes/room/[id]/+page.svelte`
- Create: `src/routes/room/[id]/+page.server.ts`
- Create: `src/lib/game-store.ts`

**Step 1: Create game state Svelte store**

Create `src/lib/game-store.ts`:

```typescript
import { writable } from 'svelte/store';
import type { GameState } from './types'; // mirror of edge function types for frontend

export const gameState = writable<GameState | null>(null);
export const myUserId = writable<string | null>(null);
```

Create `src/lib/types.ts` (mirror of `supabase/functions/_shared/types.ts` for the frontend — copy the same interfaces, import from here in Svelte components).

**Step 2: Create room page server**

Create `src/routes/room/[id]/+page.server.ts`:

```typescript
import { redirect } from '@sveltejs/kit';
import type { PageServerLoad } from './$types';

export const load: PageServerLoad = async ({ locals, params }) => {
  const { user } = await locals.safeGetSession();
  if (!user) redirect(303, '/auth');

  const [{ data: room }, { data: players }, { data: gs }] = await Promise.all([
    locals.supabase.from('game_rooms').select('*').eq('id', params.id).single(),
    locals.supabase.from('game_players').select('user_id, is_ready, profiles(username)').eq('room_id', params.id),
    locals.supabase.from('game_state').select('*').eq('room_id', params.id).maybeSingle()
  ]);

  if (!room) redirect(303, '/lobby');

  return { room, players: players ?? [], gameState: gs?.state ?? null, userId: user.id };
};
```

**Step 3: Create room page with Realtime subscription**

Create `src/routes/room/[id]/+page.svelte`:

```svelte
<script lang="ts">
  import { createClient } from '$lib/supabase';
  import { gameState, myUserId } from '$lib/game-store';
  import { onMount, onDestroy } from 'svelte';
  import type { PageData } from './$types';

  let { data }: { data: PageData } = $props();
  const supabase = createClient();

  myUserId.set(data.userId);
  if (data.gameState) gameState.set(data.gameState);

  let players = $state(data.players);
  let room = $state(data.room);
  let channel: ReturnType<typeof supabase.channel>;

  onMount(() => {
    channel = supabase.channel(`room:${data.room.id}`)
      .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'game_state', filter: `room_id=eq.${data.room.id}` },
        (payload) => { gameState.set(payload.new.state); })
      .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'game_players', filter: `room_id=eq.${data.room.id}` },
        async () => {
          const { data: updated } = await supabase.from('game_players').select('user_id, is_ready, profiles(username)').eq('room_id', data.room.id);
          if (updated) players = updated;
        })
      .subscribe();
  });

  onDestroy(() => { channel?.unsubscribe(); });

  async function callEdge(fn: string, body: object) {
    const { data: { session } } = await supabase.auth.getSession();
    const res = await fetch(`${import.meta.env.PUBLIC_SUPABASE_URL}/functions/v1/${fn}`, {
      method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${session?.access_token}` },
      body: JSON.stringify(body)
    });
    return res.json();
  }

  async function setReady() {
    await callEdge('set-ready', { room_id: data.room.id });
  }
</script>

{#if $gameState}
  <!-- Game in progress — render GameScreen -->
  <p class="p-4 text-center text-slate-400">Game in progress — game screen goes here (Task 11)</p>
{:else}
  <!-- Waiting room -->
  <div class="p-4 max-w-sm mx-auto space-y-4">
    <h1 class="text-xl font-bold">Room: {room.room_code}</h1>
    <p class="text-slate-400 text-sm">Share this code with friends</p>

    <div class="space-y-2">
      {#each players as p}
        <div class="flex items-center gap-2 p-2 bg-slate-800 rounded text-sm">
          <span class="flex-1">{(p.profiles as any)?.username ?? 'Unknown'}</span>
          <span class={p.is_ready ? 'text-green-400' : 'text-slate-500'}>{p.is_ready ? 'Ready' : 'Waiting'}</span>
        </div>
      {/each}
    </div>

    {#if !players.find(p => p.user_id === data.userId)?.is_ready}
      <button onclick={setReady} class="w-full py-2 bg-cyan-600 hover:bg-cyan-500 rounded font-medium">
        Ready
      </button>
    {:else}
      <p class="text-center text-slate-400 text-sm">Waiting for all players...</p>
    {/if}
  </div>
{/if}
```

**Step 4: Commit**

```bash
git add src/routes/room/ src/lib/game-store.ts src/lib/types.ts
git commit -m "feat: add room waiting screen with Realtime sync"
```

---

## Task 11: Game Screen UI

**Files:**
- Create: `src/lib/components/GameScreen.svelte`
- Create: `src/lib/components/HandTab.svelte`
- Create: `src/lib/components/MechTab.svelte`
- Create: `src/lib/components/EnemyTab.svelte`
- Create: `src/lib/components/ConsoleOverlay.svelte`
- Create: `src/lib/components/PartDot.svelte`
- Create: `src/lib/components/CardView.svelte`

**Step 1: Create PartDot component**

Create `src/lib/components/PartDot.svelte`:

```svelte
<script lang="ts">
  let { hp, maxHp, name, selectable = false, onSelect }: {
    hp: number; maxHp: number; name: string; selectable?: boolean; onSelect?: () => void;
  } = $props();

  const ratio = $derived(hp / maxHp);
  const color = $derived(
    hp <= 0 ? 'bg-slate-600' :
    ratio < 0.25 ? 'bg-red-500' :
    ratio < 0.6 ? 'bg-yellow-400' : 'bg-green-500'
  );
</script>

<button
  title="{name}: {hp}/{maxHp}"
  class="w-4 h-4 rounded-full {color} {selectable ? 'ring-2 ring-cyan-400 cursor-pointer' : 'cursor-default'}"
  onclick={onSelect}
  disabled={!selectable}
/>
```

**Step 2: Create CardView component**

Create `src/lib/components/CardView.svelte`:

```svelte
<script lang="ts">
  let { cardId, cardDef, selected = false, onTap }: {
    cardId: string; cardDef: any; selected?: boolean; onTap?: () => void;
  } = $props();
</script>

<button
  onclick={onTap}
  class="relative w-24 h-36 flex-shrink-0 rounded-lg border-2 {selected ? 'border-cyan-400' : 'border-slate-600'} bg-slate-800 p-1 text-left transition-transform {selected ? '-translate-y-2' : ''}"
>
  {#if cardDef?.image_url}
    <img src={cardDef.image_url} alt={cardDef.name} class="w-full h-16 object-cover rounded" />
  {:else}
    <div class="w-full h-16 rounded bg-slate-700 flex items-center justify-center text-slate-500 text-xs">
      {cardDef?.type ?? '?'}
    </div>
  {/if}
  <div class="mt-1 text-xs font-medium leading-tight">{cardDef?.name ?? cardId}</div>
  <div class="text-xs text-slate-400">{cardDef?.point_cost ?? ''}pt</div>
</button>
```

**Step 3: Create ConsoleOverlay component**

Create `src/lib/components/ConsoleOverlay.svelte`:

```svelte
<script lang="ts">
  let { frameCardId, frameStats, ap, onAbility, onClose }: {
    frameCardId: string; frameStats: any; ap: number; onAbility: (ability: string, cost: number) => void; onClose: () => void;
  } = $props();

  const abilities = $derived([
    { name: 'Shield Boost', cost: 1, description: 'SP regen doubled this upkeep' },
    { name: 'Weapon Overclock', cost: 1, description: 'Next attack +20% damage' },
    ...(frameStats?.abilities ?? [])
  ]);
</script>

<div class="fixed inset-0 bg-black/80 z-50 flex items-end" onclick={onClose}>
  <div class="w-full bg-slate-900 rounded-t-2xl p-4 space-y-3" onclick={(e) => e.stopPropagation()}>
    <div class="flex items-center justify-between">
      <div>
        <div class="text-xs text-slate-400">Active Frame</div>
        <div class="font-bold font-mono">{frameCardId}</div>
      </div>
      <button onclick={onClose} class="text-slate-400 text-sm">✕ Close</button>
    </div>

    <div class="space-y-2">
      {#each abilities as ability}
        <button
          onclick={() => onAbility(ability.name, ability.cost)}
          disabled={ap < ability.cost}
          class="w-full flex items-center justify-between p-2 bg-slate-800 rounded disabled:opacity-40 hover:bg-slate-700 text-left"
        >
          <div>
            <div class="text-sm font-medium">{ability.name}</div>
            <div class="text-xs text-slate-400">{ability.description}</div>
          </div>
          <span class="text-xs text-cyan-400">{ability.cost} AP</span>
        </button>
      {/each}
    </div>
  </div>
</div>
```

**Step 4: Create MechTab component**

Create `src/lib/components/MechTab.svelte`:

```svelte
<script lang="ts">
  import PartDot from './PartDot.svelte';
  let { player }: { player: any } = $props();
  const parts = ['head','torso','left_arm','right_arm','left_leg','right_leg'];
</script>

<div class="p-4 space-y-3">
  <div class="text-xs uppercase tracking-wider text-slate-400">My Mech</div>
  {#each parts as part}
    {@const p = player?.parts[part]}
    {#if p}
      <div class="flex items-center gap-3 p-2 bg-slate-800 rounded text-sm">
        <PartDot hp={p.hp} maxHp={p.max_hp} name={part} />
        <span class="flex-1 capitalize">{part.replace('_', ' ')}</span>
        <span class="text-slate-400">{p.hp}/{p.max_hp}</span>
        {#if p.armor > 0}<span class="text-cyan-400 text-xs">{p.armor}arm</span>{/if}
        {#each p.installed_components.filter((c: any) => c.is_active) as comp}
          <span class="text-xs bg-slate-700 rounded px-1">{comp.card_id}</span>
        {/each}
      </div>
    {/if}
  {/each}

  {#if player?.shield}
    <div class="p-2 bg-slate-800 rounded text-sm flex items-center gap-2">
      <span class="text-blue-400">Shield</span>
      <div class="flex-1 bg-slate-700 rounded-full h-2">
        <div class="bg-blue-400 h-2 rounded-full" style="width: {(player.shield.sp / player.shield.max_sp) * 100}%"></div>
      </div>
      <span class="text-slate-400 text-xs">{player.shield.sp}/{player.shield.max_sp}</span>
    </div>
  {/if}

  {#if player?.status_effects?.length}
    <div class="text-xs text-slate-400">Status: {player.status_effects.map((se: any) => se.effect).join(', ')}</div>
  {/if}
</div>
```

**Step 5: Create EnemyTab component**

Create `src/lib/components/EnemyTab.svelte`:

```svelte
<script lang="ts">
  import PartDot from './PartDot.svelte';
  let { enemies, phase, hasTargeting, onSelectTarget }: {
    enemies: { userId: string; state: any }[];
    phase: string; hasTargeting: boolean;
    onSelectTarget: (userId: string, part: string) => void;
  } = $props();

  let currentEnemy = $state(0);
  const enemy = $derived(enemies[currentEnemy]);
  const parts = ['head','torso','left_arm','right_arm','left_leg','right_leg'];
  const canTarget = $derived(phase === 'combat' && !enemy?.state.is_eliminated);
</script>

<div class="p-4 space-y-3">
  {#if enemies.length > 1}
    <div class="flex gap-2">
      {#each enemies as e, i}
        <button onclick={() => currentEnemy = i}
          class="flex-1 text-xs py-1 rounded {i === currentEnemy ? 'bg-slate-700' : 'bg-slate-900'}">
          {e.userId.slice(0, 6)}
        </button>
      {/each}
    </div>
  {/if}

  {#if enemy}
    <div class="text-xs text-slate-400">Targeting: {enemy.userId.slice(0, 8)}…</div>
    {#each parts as part}
      {@const p = enemy.state.parts[part]}
      {#if p}
        <div class="flex items-center gap-3 p-2 bg-slate-800 rounded text-sm">
          <PartDot hp={p.hp} maxHp={p.max_hp} name={part}
            selectable={canTarget && hasTargeting}
            onSelect={() => onSelectTarget(enemy.userId, part)} />
          <span class="flex-1 capitalize">{part.replace('_', ' ')}</span>
          <span class="text-slate-400">{p.hp}/{p.max_hp}</span>
        </div>
      {/if}
    {/each}
  {:else}
    <p class="text-slate-400 text-sm">No enemies remaining.</p>
  {/if}
</div>
```

**Step 6: Create HandTab component**

Create `src/lib/components/HandTab.svelte`:

```svelte
<script lang="ts">
  import CardView from './CardView.svelte';
  let { player, phase, cardDefs, onPlayCard, onDiscardCard, onFire }: {
    player: any; phase: string; cardDefs: Record<string, any>;
    onPlayCard: (cardId: string, installPart?: string) => void;
    onDiscardCard: (cardId: string) => void;
    onFire: (weaponCardId: string) => void;
  } = $props();

  let selected = $state<string | null>(null);

  const weapons = $derived(
    phase === 'combat'
      ? Object.values(player.parts as Record<string, any>)
          .flatMap((p: any) => p.installed_components)
          .filter((c: any) => c.is_active && cardDefs[c.card_id]?.stats?.slot_type === 'weapon')
      : []
  );
</script>

<div class="p-4 space-y-4">
  {#if phase === 'combat'}
    <div class="text-xs text-slate-400 uppercase tracking-wider">Weapons</div>
    <div class="flex gap-2 overflow-x-auto pb-2">
      {#each weapons as w}
        <button onclick={() => onFire(w.card_id)}
          disabled={player.ap < 1}
          class="flex-shrink-0 px-3 py-2 bg-slate-800 border border-slate-600 rounded text-sm disabled:opacity-40 hover:border-cyan-500">
          {cardDefs[w.card_id]?.name ?? w.card_id}
          <span class="block text-xs text-slate-400">1 AP</span>
        </button>
      {/each}
      {#if weapons.length === 0}
        <p class="text-slate-500 text-sm">No weapons installed.</p>
      {/if}
    </div>
  {:else}
    <div class="text-xs text-slate-400 uppercase tracking-wider">Hand ({player.hand.length})</div>
    <div class="flex gap-2 overflow-x-auto pb-2">
      {#each player.hand as cardId}
        <CardView
          {cardId} cardDef={cardDefs[cardId]}
          selected={selected === cardId}
          onTap={() => selected = selected === cardId ? null : cardId}
        />
      {/each}
    </div>

    {#if selected}
      <div class="flex gap-2">
        <button onclick={() => { onPlayCard(selected!); selected = null; }}
          class="flex-1 py-2 bg-cyan-600 hover:bg-cyan-500 rounded text-sm">Play</button>
        <button onclick={() => { onDiscardCard(selected!); selected = null; }}
          class="flex-1 py-2 bg-slate-700 hover:bg-slate-600 rounded text-sm">Discard for Effect</button>
      </div>
    {/if}
  {/if}
</div>
```

**Step 7: Create GameScreen component**

Create `src/lib/components/GameScreen.svelte`:

```svelte
<script lang="ts">
  import HandTab from './HandTab.svelte';
  import MechTab from './MechTab.svelte';
  import EnemyTab from './EnemyTab.svelte';
  import ConsoleOverlay from './ConsoleOverlay.svelte';
  import PartDot from './PartDot.svelte';
  import { gameState, myUserId } from '$lib/game-store';
  import { createClient } from '$lib/supabase';

  let { roomId, cardDefs }: { roomId: string; cardDefs: Record<string, any> } = $props();

  const supabase = createClient();
  let tab = $state<'hand' | 'mech' | 'enemy'>('hand');
  let showConsole = $state(false);
  let toastMsg = $state('');

  const state = $derived($gameState);
  const uid = $derived($myUserId);
  const me = $derived(state?.players[uid!]);
  const isMyTurn = $derived(state?.active_player_id === uid);
  const enemies = $derived(
    Object.entries(state?.players ?? {})
      .filter(([id, p]) => id !== uid && !(p as any).is_eliminated)
      .map(([userId, playerState]) => ({ userId, state: playerState }))
  );

  function toast(msg: string) { toastMsg = msg; setTimeout(() => toastMsg = '', 3000); }

  async function callEdge(fn: string, body: object) {
    const { data: { session } } = await supabase.auth.getSession();
    const res = await fetch(`${import.meta.env.PUBLIC_SUPABASE_URL}/functions/v1/${fn}`, {
      method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${session?.access_token}` },
      body: JSON.stringify({ room_id: roomId, ...body })
    });
    const data = await res.json();
    if (data.error) toast(data.error);
    return data;
  }

  async function playCard(cardId: string, installPart?: string) {
    await callEdge('play-card', { card_id: cardId, install_part: installPart });
  }

  async function discardCard(cardId: string) {
    await callEdge('discard-card', { card_id: cardId });
  }

  let pendingWeapon = $state<string | null>(null);

  function fireWeapon(weaponCardId: string) {
    pendingWeapon = weaponCardId;
    tab = 'enemy';
    toast('Select a target part on the Enemy tab');
  }

  async function selectTarget(targetUserId: string, targetPart: string) {
    if (!pendingWeapon) return;
    await callEdge('attack', { weapon_card_id: pendingWeapon, target_user_id: targetUserId, target_part: targetPart });
    pendingWeapon = null;
    tab = 'hand';
  }

  async function endTurn() {
    await callEdge('end-turn', {});
  }

  async function useAbility(abilityName: string, cost: number) {
    await callEdge('change-ability', { ability: abilityName });
    showConsole = false;
  }
</script>

<div class="flex flex-col h-screen max-h-screen">
  <!-- Top bar -->
  <div class="flex items-center justify-between px-3 py-2 bg-slate-900 border-b border-slate-700 flex-shrink-0">
    <span class="text-xs text-slate-400 uppercase">{state?.phase ?? '—'}</span>
    <span class="text-sm font-mono">AP: {me?.ap ?? 0}/{me?.ap_per_turn ?? 0}</span>
    <button onclick={endTurn} disabled={!isMyTurn}
      class="px-3 py-1 bg-red-700 hover:bg-red-600 disabled:opacity-30 rounded text-xs font-bold">
      END TURN
    </button>
  </div>

  <!-- Mech portrait bar -->
  <div class="flex items-center gap-3 px-3 py-2 bg-slate-900 border-b border-slate-800 flex-shrink-0">
    <button onclick={() => showConsole = true} class="w-10 h-10 rounded bg-slate-700 flex items-center justify-center text-lg">
      🤖
    </button>
    <div class="flex-1 space-y-1">
      <div class="flex items-center gap-1 h-2">
        {@const totalHp = me ? Object.values(me.parts).reduce((s, p) => s + (p as any).hp, 0) : 0}
        {@const maxHp = me ? Object.values(me.parts).reduce((s, p) => s + (p as any).max_hp, 0) : 1}
        <div class="flex-1 bg-slate-700 rounded-full h-2">
          <div class="bg-green-500 h-2 rounded-full transition-all" style="width: {(totalHp / maxHp) * 100}%"></div>
        </div>
        <span class="text-xs text-slate-400">{totalHp}</span>
      </div>
      {#if me?.shield}
        <div class="flex items-center gap-1 h-2">
          <div class="flex-1 bg-slate-700 rounded-full h-2">
            <div class="bg-blue-500 h-2 rounded-full transition-all" style="width: {(me.shield.sp / me.shield.max_sp) * 100}%"></div>
          </div>
          <span class="text-xs text-slate-400">{me.shield.sp}</span>
        </div>
      {/if}
    </div>
    <div class="flex gap-1">
      {#each ['head','torso','left_arm','right_arm','left_leg','right_leg'] as part}
        {@const p = me?.parts[part]}
        {#if p}
          <PartDot hp={(p as any).hp} maxHp={(p as any).max_hp} name={part} />
        {/if}
      {/each}
    </div>
  </div>

  <!-- Tab content -->
  <div class="flex-1 overflow-y-auto">
    {#if tab === 'hand'}
      <HandTab player={me} phase={state?.phase ?? 'build'} {cardDefs} onPlayCard={playCard} onDiscardCard={discardCard} onFire={fireWeapon} />
    {:else if tab === 'mech'}
      <MechTab player={me} />
    {:else}
      <EnemyTab {enemies} phase={state?.phase ?? 'build'} hasTargeting={me?.targeting_system ?? false} onSelectTarget={selectTarget} />
    {/if}
  </div>

  <!-- Toast -->
  {#if toastMsg}
    <div class="absolute top-16 left-0 right-0 flex justify-center pointer-events-none">
      <div class="bg-slate-700 text-sm px-4 py-2 rounded-full shadow-lg">{toastMsg}</div>
    </div>
  {/if}

  <!-- Tab bar -->
  <div class="flex border-t border-slate-700 bg-slate-900 flex-shrink-0">
    {#each [['hand', 'Hand'], ['mech', 'My Mech'], ['enemy', 'Enemy']] as [t, label]}
      <button onclick={() => tab = t as any}
        class="flex-1 py-3 text-sm {tab === t ? 'text-cyan-400 border-t-2 border-cyan-400' : 'text-slate-400'}">
        {label}
      </button>
    {/each}
  </div>
</div>

{#if showConsole}
  <ConsoleOverlay
    frameCardId={me?.frame_card_id ?? ''}
    frameStats={cardDefs[me?.frame_card_id ?? '']?.stats}
    ap={me?.ap ?? 0}
    onAbility={useAbility}
    onClose={() => showConsole = false}
  />
{/if}
```

**Step 8: Wire GameScreen into room page**

In `src/routes/room/[id]/+page.svelte`, replace the placeholder comment with:

```svelte
<!-- Load card defs from server, pass to GameScreen -->
<GameScreen roomId={data.room.id} cardDefs={data.cardDefs} />
```

Add to `src/routes/room/[id]/+page.server.ts` load function:
```typescript
const { data: allCards } = await locals.supabase.from('card_definitions').select('*');
const cardDefs = Object.fromEntries((allCards ?? []).map(c => [c.id, c]));
// add cardDefs to return
return { room, players: players ?? [], gameState: gs?.state ?? null, userId: user.id, cardDefs };
```

**Step 9: Commit**

```bash
git add src/lib/components/ src/routes/room/
git commit -m "feat: add game screen UI with Hand/Mech/Enemy tabs and Console overlay"
```

---

## Task 12: Pack Opening, Economy & change-ability Edge Function

**Files:**
- Create: `supabase/functions/open-pack/index.ts`
- Create: `supabase/functions/change-ability/index.ts`
- Create: `supabase/functions/salvage/index.ts`
- Create: `src/routes/collection/+page.svelte`
- Create: `src/routes/collection/+page.server.ts`

**Step 1: Create change-ability Edge Function**

Create `supabase/functions/change-ability/index.ts`:

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import type { GameState } from '../_shared/types.ts';

Deno.serve(async (req) => {
  const supabase = createClient(Deno.env.get('SUPABASE_URL')!, Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
    { global: { headers: { Authorization: req.headers.get('Authorization')! } } });

  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 });

  const { room_id, ability } = await req.json();
  const { data: gs } = await supabase.from('game_state').select('*').eq('room_id', room_id).single();
  const state: GameState = gs?.state;
  if (!state || state.active_player_id !== user.id) return new Response(JSON.stringify({ error: 'Not your turn' }), { status: 403 });

  const player = state.players[user.id];

  if (ability === 'Shield Boost') {
    if (player.ap < 1) return new Response(JSON.stringify({ error: 'No AP' }), { status: 400 });
    player.ap -= 1;
    if (player.shield) player.shield.sp = Math.min(player.shield.max_sp, player.shield.sp + player.shield.regen);
    state.log.push(`${user.id} used Shield Boost`);
  } else if (ability === 'Weapon Overclock') {
    if (player.ap < 1) return new Response(JSON.stringify({ error: 'No AP' }), { status: 400 });
    player.ap -= 1;
    player.status_effects.push({ effect: 'energized', turns_remaining: 1 });
    state.log.push(`${user.id} used Weapon Overclock`);
  }

  await supabase.from('game_state').update({ state, updated_at: new Date().toISOString() }).eq('room_id', room_id);
  return new Response(JSON.stringify({ ok: true }), { headers: { 'Content-Type': 'application/json' } });
});
```

**Step 2: Create salvage Edge Function**

Create `supabase/functions/salvage/index.ts`:

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import type { GameState } from '../_shared/types.ts';

Deno.serve(async (req) => {
  const supabase = createClient(Deno.env.get('SUPABASE_URL')!, Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
    { global: { headers: { Authorization: req.headers.get('Authorization')! } } });

  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 });

  const { room_id, target_user_id, card_id } = await req.json();
  const { data: gs } = await supabase.from('game_state').select('*').eq('room_id', room_id).single();
  const state: GameState = gs?.state;
  if (!state) return new Response(JSON.stringify({ error: 'Game not found' }), { status: 404 });

  const target = state.players[target_user_id];
  if (!target?.is_eliminated) return new Response(JSON.stringify({ error: 'Target not eliminated' }), { status: 400 });

  // Check protection
  const { data: cardDef } = await supabase.from('card_definitions').select('rarity, is_starter').eq('id', card_id).single();
  if (!cardDef) return new Response(JSON.stringify({ error: 'Card not found' }), { status: 404 });
  if (cardDef.is_starter) return new Response(JSON.stringify({ error: 'Starter cards are protected' }), { status: 403 });
  if (cardDef.rarity === 'legendary') return new Response(JSON.stringify({ error: 'Legendary cards are protected' }), { status: 403 });
  if (cardDef.rarity === 'epic') {
    const protected_ = Math.random() < 0.5;
    if (protected_) return new Response(JSON.stringify({ error: 'Epic card was protected this time' }), { status: 403 });
  }

  // Add to salvager's collection
  await supabase.from('user_collections').upsert(
    { user_id: user.id, card_id, quantity: 1 },
    { onConflict: 'user_id,card_id', ignoreDuplicates: false }
  );

  state.log.push(`${user.id} salvaged ${card_id} from ${target_user_id}`);
  await supabase.from('game_state').update({ state, updated_at: new Date().toISOString() }).eq('room_id', room_id);
  return new Response(JSON.stringify({ ok: true }), { headers: { 'Content-Type': 'application/json' } });
});
```

**Step 3: Create open-pack Edge Function**

Create `supabase/functions/open-pack/index.ts`:

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

function weightedRandom(weights: Record<string, number>): string {
  const total = Object.values(weights).reduce((s, v) => s + v, 0);
  let r = Math.random() * total;
  for (const [key, weight] of Object.entries(weights)) {
    r -= weight;
    if (r <= 0) return key;
  }
  return Object.keys(weights)[0];
}

Deno.serve(async (req) => {
  const supabase = createClient(Deno.env.get('SUPABASE_URL')!, Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
    { global: { headers: { Authorization: req.headers.get('Authorization')! } } });

  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 });

  const { pack_id } = await req.json();

  const { data: pack } = await supabase.from('packs').select('*').eq('id', pack_id).single();
  if (!pack) return new Response(JSON.stringify({ error: 'Pack not found' }), { status: 404 });

  const CARDS_PER_PACK = 5;
  const weights = pack.rarity_weights as Record<string, number>;

  const pulled: string[] = [];
  for (let i = 0; i < CARDS_PER_PACK; i++) {
    const rarity = weightedRandom(weights);
    const { data: cards } = await supabase.from('card_definitions').select('id').eq('rarity', rarity);
    if (cards && cards.length > 0) {
      pulled.push(cards[Math.floor(Math.random() * cards.length)].id);
    }
  }

  // Add to collection
  for (const cardId of pulled) {
    await supabase.from('user_collections').upsert(
      { user_id: user.id, card_id: cardId, quantity: 1 },
      { onConflict: 'user_id,card_id', ignoreDuplicates: false }
    );
  }

  return new Response(JSON.stringify({ cards: pulled }), { headers: { 'Content-Type': 'application/json' } });
});
```

**Step 4: Create collection/shop page server**

Create `src/routes/collection/+page.server.ts`:

```typescript
import { redirect } from '@sveltejs/kit';
import type { PageServerLoad, Actions } from './$types';

export const load: PageServerLoad = async ({ locals }) => {
  const { user } = await locals.safeGetSession();
  if (!user) redirect(303, '/auth');

  const [{ data: collection }, { data: profile }] = await Promise.all([
    locals.supabase.from('user_collections').select('card_id, quantity, card_definitions(name, type, rarity, point_cost, image_url)').eq('user_id', user.id),
    locals.supabase.from('profiles').select('scrap').eq('id', user.id).single()
  ]);

  return { collection: collection ?? [], scrap: profile?.scrap ?? 0 };
};

export const actions: Actions = {
  dismantle: async ({ locals, request }) => {
    const { user } = await locals.safeGetSession();
    if (!user) redirect(303, '/auth');
    const form = await request.formData();
    const cardId = form.get('card_id') as string;
    const qty = parseInt(form.get('quantity') as string, 10);

    const SCRAP_VALUES: Record<string, number> = { common: 5, uncommon: 15, rare: 40, epic: 100, legendary: 400 };
    const { data: cardDef } = await locals.supabase.from('card_definitions').select('rarity, is_starter').eq('id', cardId).single();
    if (!cardDef || cardDef.is_starter) return;

    const scrapGain = (SCRAP_VALUES[cardDef.rarity] ?? 5) * qty;
    await Promise.all([
      locals.supabase.from('user_collections').update({ quantity: locals.supabase.rpc('decrement', { x: qty }) }).eq('user_id', user.id).eq('card_id', cardId),
      locals.supabase.from('profiles').update({ scrap: locals.supabase.rpc('increment_scrap', { amount: scrapGain }) }).eq('id', user.id)
    ]);
  }
};
```

**Step 5: Create collection page UI**

Create `src/routes/collection/+page.svelte`:

```svelte
<script lang="ts">
  import type { PageData } from './$types';
  let { data }: { data: PageData } = $props();

  const RARITY_COLOR: Record<string, string> = {
    common: 'text-slate-300', uncommon: 'text-green-400', rare: 'text-blue-400',
    epic: 'text-purple-400', legendary: 'text-yellow-400'
  };
</script>

<div class="p-4 max-w-lg mx-auto space-y-4">
  <div class="flex items-center justify-between">
    <h1 class="text-xl font-bold">Collection</h1>
    <span class="text-sm text-yellow-400">⚙ {data.scrap} Scrap</span>
  </div>

  <div class="space-y-1">
    {#each data.collection as entry}
      {@const card = entry.card_definitions as any}
      <div class="flex items-center gap-3 p-2 bg-slate-800 rounded text-sm">
        <div class="flex-1">
          <span class={RARITY_COLOR[card?.rarity ?? 'common']}>{card?.name ?? entry.card_id}</span>
          <span class="text-slate-500 text-xs ml-2">{card?.type}</span>
        </div>
        <span class="text-slate-400">×{entry.quantity}</span>
        <form method="POST" action="?/dismantle">
          <input type="hidden" name="card_id" value={entry.card_id} />
          <input type="hidden" name="quantity" value="1" />
          <button type="submit" class="text-xs text-red-400 hover:text-red-300">Dismantle</button>
        </form>
      </div>
    {:else}
      <p class="text-slate-400 text-sm">No cards yet. Play matches to earn packs!</p>
    {/each}
  </div>
</div>
```

**Step 6: Commit**

```bash
git add supabase/functions/ src/routes/collection/
git commit -m "feat: add pack opening, salvage, change-ability, and collection UI"
```

---

## Task 13: AI Opponents & Balancing Tool

**Files:**
- Create: `supabase/functions/simulate-match/index.ts`
- Create: `tools/balancer/index.ts`
- Create: `tools/balancer/ai-player.ts`

**Step 1: Create AI player logic**

Create `tools/balancer/ai-player.ts`:

```typescript
import type { GameState, PlayerState } from '../../supabase/functions/_shared/types';
import { resolveDamage, rollDice } from '../../supabase/functions/_shared/damage';

export type Difficulty = 'easy' | 'normal' | 'hard';

export function aiChooseAction(state: GameState, userId: string, difficulty: Difficulty, cardDefs: Record<string, any>): { action: string; params: Record<string, any> } | null {
  const player = state.players[userId];
  if (player.ap < 1) return null;

  const phase = state.phase;

  if (phase === 'build') {
    // Play an energy card if available
    const energyCard = player.hand.find(id => cardDefs[id]?.type === 'energy');
    if (energyCard) return { action: 'play-card', params: { card_id: energyCard } };

    // Install a component if uninstalled weapons exist
    const componentCard = player.hand.find(id => cardDefs[id]?.type === 'component');
    if (componentCard) {
      const stats = cardDefs[componentCard]?.stats;
      const installPart = stats?.part_restriction?.[0] ?? 'torso';
      return { action: 'play-card', params: { card_id: componentCard, install_part: installPart } };
    }

    return null; // end build phase
  }

  if (phase === 'combat') {
    // Find first active weapon
    const weapons = Object.values(player.parts)
      .flatMap(p => p.installed_components)
      .filter(c => c.is_active && cardDefs[c.card_id]?.stats?.slot_type === 'weapon');

    if (weapons.length === 0) return null;

    // Pick a living enemy
    const enemies = state.turn_order.filter(uid => uid !== userId && !state.players[uid].is_eliminated);
    if (enemies.length === 0) return null;

    const targetUserId = enemies[0];
    const targetPart = difficulty === 'hard' ? 'torso' : 'head'; // hard mode targets torso (most HP)

    return { action: 'attack', params: { weapon_card_id: weapons[0].card_id, target_user_id: targetUserId, target_part: targetPart } };
  }

  return null;
}
```

**Step 2: Create balancer script**

Create `tools/balancer/index.ts`:

```typescript
import { createClient } from '@supabase/supabase-js';
import { buildPlayerState, applyUpkeep, advanceTurn } from '../../supabase/functions/_shared/game-engine';
import { resolveDamage, rollDice } from '../../supabase/functions/_shared/damage';
import { aiChooseAction } from './ai-player';
import type { GameState } from '../../supabase/functions/_shared/types';

const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_SERVICE_ROLE_KEY!);

async function runSimulation(deckIds: string[], numGames = 100): Promise<void> {
  const { data: cardDefs } = await supabase.from('card_definitions').select('*');
  const cardDefMap = Object.fromEntries((cardDefs ?? []).map((c: any) => [c.id, c]));

  const stats: Record<string, { wins: number; games: number; totalDamage: number }> = {};

  for (let g = 0; g < numGames; g++) {
    // Build initial state with AI players
    let state: GameState = { players: {}, turn_order: [], phase: 'upkeep', turn_number: 1, active_player_id: '', log: [] };
    const playerIds = deckIds.map((_, i) => `ai-${i}`);

    for (let i = 0; i < deckIds.length; i++) {
      const { data: deckCards } = await supabase.from('deck_cards').select('card_id, quantity, card_definitions(stats, type)').eq('deck_id', deckIds[i]);
      const deckCardIds: string[] = [];
      let frameCard: any = null;
      for (const dc of deckCards ?? []) {
        if ((dc.card_definitions as any).type === 'frame' && !frameCard) frameCard = { id: dc.card_id, stats: (dc.card_definitions as any).stats };
        for (let j = 0; j < dc.quantity; j++) deckCardIds.push(dc.card_id);
      }
      if (!frameCard) continue;
      state.players[playerIds[i]] = buildPlayerState(playerIds[i], frameCard, deckCardIds);
      state.turn_order.push(playerIds[i]);
    }
    state.active_player_id = playerIds[0];
    state = applyUpkeep(state);

    // Simulate up to 200 turns
    let turnCount = 0;
    while (turnCount < 200) {
      const living = state.turn_order.filter(uid => !state.players[uid].is_eliminated);
      if (living.length <= 1) break;

      const action = aiChooseAction(state, state.active_player_id, 'normal', cardDefMap);
      if (!action) {
        // Advance phase: build → combat → end turn
        if (state.phase === 'build') {
          state.phase = 'combat';
        } else {
          state = advanceTurn(state);
          state = applyUpkeep(state);
          turnCount++;
        }
        continue;
      }

      if (action.action === 'attack') {
        const attacker = state.players[state.active_player_id];
        attacker.ap -= 1;
        const { weapon_card_id, target_user_id, target_part } = action.params;
        const weaponStats = cardDefMap[weapon_card_id]?.stats;
        if (weaponStats) {
          const damage = rollDice(weaponStats.damage);
          const result = resolveDamage(state.players[target_user_id], damage, target_part, weaponStats.energy_type ?? 'kinetic');
          state.players[target_user_id] = result.targetState;
        }
      }
    }

    const winner = state.turn_order.find(uid => !state.players[uid].is_eliminated);
    for (const uid of state.turn_order) {
      if (!stats[uid]) stats[uid] = { wins: 0, games: 0, totalDamage: 0 };
      stats[uid].games++;
      if (uid === winner) stats[uid].wins++;
    }
  }

  console.log('\n=== Balancer Results ===');
  for (const [uid, s] of Object.entries(stats)) {
    console.log(`${uid}: ${s.wins}/${s.games} wins (${((s.wins / s.games) * 100).toFixed(1)}%)`);
  }
}

// Usage: npx tsx tools/balancer/index.ts <deck-id-1> <deck-id-2>
const deckIds = process.argv.slice(2);
if (deckIds.length < 2) { console.error('Pass at least 2 deck IDs'); process.exit(1); }
runSimulation(deckIds, 100).catch(console.error);
```

**Step 3: Create simulate-match Edge Function (for in-game AI)**

Create `supabase/functions/simulate-match/index.ts`:

```typescript
// This function provides AI opponent turns during live matches.
// It is called by the game client when it's an AI player's turn.
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { aiChooseAction } from '../_shared/ai-player.ts';
import type { GameState } from '../_shared/types.ts';

Deno.serve(async (req) => {
  const supabase = createClient(Deno.env.get('SUPABASE_URL')!, Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!);
  const { room_id, ai_user_id } = await req.json();

  const { data: gs } = await supabase.from('game_state').select('*').eq('room_id', room_id).single();
  if (!gs || gs.state.active_player_id !== ai_user_id) return new Response(JSON.stringify({ ok: false }), { status: 400 });

  const { data: cardDefs } = await supabase.from('card_definitions').select('*');
  const cardDefMap = Object.fromEntries((cardDefs ?? []).map((c: any) => [c.id, c]));

  // Run AI actions until it ends its turn
  let state: GameState = gs.state;
  let iterations = 0;
  while (state.active_player_id === ai_user_id && iterations < 20) {
    const action = aiChooseAction(state, ai_user_id, 'normal', cardDefMap);
    if (!action) break;
    // Apply action to state directly (simplified — production would call edge functions)
    iterations++;
  }

  await supabase.from('game_state').update({ state, updated_at: new Date().toISOString() }).eq('room_id', room_id);
  return new Response(JSON.stringify({ ok: true }), { headers: { 'Content-Type': 'application/json' } });
});
```

**Step 4: Add ai-player.ts to shared functions folder**

Copy `tools/balancer/ai-player.ts` logic into `supabase/functions/_shared/ai-player.ts` adapted for Deno imports.

**Step 5: Commit**

```bash
git add tools/ supabase/functions/simulate-match/ supabase/functions/_shared/ai-player.ts
git commit -m "feat: add AI player logic and balancing tool"
```

---

## Task 14: Player-to-Player Trading

**Files:**
- Create: `supabase/functions/initiate-trade/index.ts`
- Create: `supabase/functions/respond-trade/index.ts`
- Create: `src/routes/trade/+page.svelte`
- Create: `src/routes/trade/+page.server.ts`

**Step 1: Create initiate-trade Edge Function**

Create `supabase/functions/initiate-trade/index.ts`:

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

Deno.serve(async (req) => {
  const supabase = createClient(Deno.env.get('SUPABASE_URL')!, Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
    { global: { headers: { Authorization: req.headers.get('Authorization')! } } });

  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 });

  const { recipient_id, offered_card_ids, requested_card_ids } = await req.json();

  // Verify initiator owns all offered cards
  for (const cardId of offered_card_ids) {
    const { data } = await supabase.from('user_collections')
      .select('quantity, card_definitions(is_starter)')
      .eq('user_id', user.id).eq('card_id', cardId).single();
    if (!data || data.quantity < 1) return new Response(JSON.stringify({ error: `You don't own ${cardId}` }), { status: 400 });
    if ((data.card_definitions as any)?.is_starter) return new Response(JSON.stringify({ error: 'Starter cards cannot be traded' }), { status: 403 });
  }

  const { data: trade, error } = await supabase.from('trades').insert({
    initiator_id: user.id, recipient_id, offered_card_ids, requested_card_ids
  }).select('id').single();

  if (error) return new Response(JSON.stringify({ error: error.message }), { status: 500 });
  return new Response(JSON.stringify({ trade_id: trade?.id }), { headers: { 'Content-Type': 'application/json' } });
});
```

**Step 2: Create respond-trade Edge Function**

Create `supabase/functions/respond-trade/index.ts`:

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

Deno.serve(async (req) => {
  const supabase = createClient(Deno.env.get('SUPABASE_URL')!, Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
    { global: { headers: { Authorization: req.headers.get('Authorization')! } } });

  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 });

  const { trade_id, accept } = await req.json();

  const { data: trade } = await supabase.from('trades').select('*').eq('id', trade_id).eq('recipient_id', user.id).eq('status', 'pending').single();
  if (!trade) return new Response(JSON.stringify({ error: 'Trade not found' }), { status: 404 });

  if (!accept) {
    await supabase.from('trades').update({ status: 'rejected' }).eq('id', trade_id);
    return new Response(JSON.stringify({ ok: true }), { headers: { 'Content-Type': 'application/json' } });
  }

  // Verify recipient owns requested cards
  for (const cardId of trade.requested_card_ids) {
    const { data } = await supabase.from('user_collections').select('quantity').eq('user_id', user.id).eq('card_id', cardId).single();
    if (!data || data.quantity < 1) return new Response(JSON.stringify({ error: `You don't own ${cardId}` }), { status: 400 });
  }

  // Swap collections
  const transfers = [
    ...trade.offered_card_ids.map((id: string) => ({ from: trade.initiator_id, to: user.id, card_id: id })),
    ...trade.requested_card_ids.map((id: string) => ({ from: user.id, to: trade.initiator_id, card_id: id }))
  ];

  for (const t of transfers) {
    // Decrement from sender
    await supabase.rpc('decrement_card', { p_user_id: t.from, p_card_id: t.card_id });
    // Increment to receiver
    await supabase.from('user_collections').upsert({ user_id: t.to, card_id: t.card_id, quantity: 1 }, { onConflict: 'user_id,card_id', ignoreDuplicates: false });
  }

  await supabase.from('trades').update({ status: 'accepted' }).eq('id', trade_id);
  return new Response(JSON.stringify({ ok: true }), { headers: { 'Content-Type': 'application/json' } });
});
```

**Step 3: Add decrement_card Postgres function**

Add to a new migration `supabase/migrations/0002_rpc_helpers.sql`:

```sql
create or replace function public.decrement_card(p_user_id uuid, p_card_id text)
returns void language plpgsql as $$
begin
  update public.user_collections
    set quantity = quantity - 1
    where user_id = p_user_id and card_id = p_card_id;
  delete from public.user_collections where user_id = p_user_id and card_id = p_card_id and quantity <= 0;
end;
$$;
```

Apply: `npx supabase db push`

**Step 4: Commit**

```bash
git add supabase/functions/initiate-trade/ supabase/functions/respond-trade/ supabase/migrations/0002_rpc_helpers.sql
git commit -m "feat: add player-to-player trading edge functions"
```

---

## Task 15: PWA Configuration

**Files:**
- Create: `static/manifest.json`
- Create: `static/sw.js`
- Modify: `src/app.html`

**Step 1: Create web manifest**

Create `static/manifest.json`:

```json
{
  "name": "BetterGame",
  "short_name": "BetterGame",
  "description": "Mech combat card game",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#0f172a",
  "theme_color": "#0f172a",
  "orientation": "portrait",
  "icons": [
    { "src": "/icons/icon-192.png", "sizes": "192x192", "type": "image/png" },
    { "src": "/icons/icon-512.png", "sizes": "512x512", "type": "image/png" }
  ]
}
```

**Step 2: Create minimal service worker**

Create `static/sw.js`:

```javascript
const CACHE = 'bettergame-v1';
const PRECACHE = ['/', '/auth'];

self.addEventListener('install', e => {
  e.waitUntil(caches.open(CACHE).then(c => c.addAll(PRECACHE)));
  self.skipWaiting();
});

self.addEventListener('activate', e => {
  e.waitUntil(caches.keys().then(keys =>
    Promise.all(keys.filter(k => k !== CACHE).map(k => caches.delete(k)))
  ));
  self.clients.claim();
});

self.addEventListener('fetch', e => {
  if (e.request.method !== 'GET') return;
  e.respondWith(
    fetch(e.request).catch(() => caches.match(e.request))
  );
});
```

**Step 3: Register service worker and manifest in app.html**

In `src/app.html`, add inside `<head>`:

```html
<link rel="manifest" href="/manifest.json" />
<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js');
  }
</script>
```

**Step 4: Verify PWA installability**

```bash
npm run build && npm run preview
```

Open Chrome DevTools → Application → Manifest. Confirm no errors. Test "Add to Home Screen".

**Step 5: Commit**

```bash
git add static/ src/app.html
git commit -m "feat: add PWA manifest and service worker"
```

---

## Task 16: Match Reward Distribution

**Files:**
- Modify: `supabase/functions/end-turn/index.ts`
- Create: `supabase/functions/_shared/rewards.ts`

**Step 1: Create rewards helper**

Create `supabase/functions/_shared/rewards.ts`:

```typescript
export const PACK_REWARDS: Record<string, { winner: string; loser: string }> = {
  pvp: { winner: 'elite', loser: 'standard' },
  ai: { winner: 'advanced', loser: 'standard' }
};

export async function grantMatchRewards(supabase: any, matchId: string, players: { userId: string; placement: number; isAi: boolean }[], isVsAi: boolean) {
  for (const p of players) {
    if (p.isAi) continue;
    const tier = isVsAi
      ? (p.placement === 1 ? PACK_REWARDS.ai.winner : PACK_REWARDS.ai.loser)
      : (p.placement === 1 ? PACK_REWARDS.pvp.winner : PACK_REWARDS.pvp.loser);

    // Grant pack token — store in a pending_packs table or call open-pack directly
    await supabase.from('user_collections').insert({ user_id: p.userId, card_id: `PACK_TOKEN_${tier.toUpperCase()}`, quantity: 1 })
      .onConflict('user_id,card_id').ignore();
  }
}
```

**Step 2: Update end-turn to distribute rewards on game over**

In `supabase/functions/end-turn/index.ts`, in the game-over block after inserting `match_history`:

```typescript
import { grantMatchRewards } from '../_shared/rewards.ts';
// after match_history insert:
const { data: match } = await supabase.from('match_history').select('id').eq('room_id', room_id).single();
if (match) {
  const playerResults = living.map((uid, i) => ({ userId: uid, placement: i + 1, isAi: uid.startsWith('ai-') }));
  await grantMatchRewards(supabase, match.id, playerResults, false);
}
```

**Step 3: Commit**

```bash
git add supabase/functions/_shared/rewards.ts supabase/functions/end-turn/
git commit -m "feat: add match reward distribution"
```

---

## Task 17: End-to-End Test & Smoke Test

**Files:**
- Create: `tests/smoke.test.ts` (Playwright)

**Step 1: Install Playwright**

```bash
npm install -D @playwright/test
npx playwright install chromium
```

**Step 2: Write smoke test**

Create `tests/smoke.test.ts`:

```typescript
import { test, expect } from '@playwright/test';

test('guest can reach lobby', async ({ page }) => {
  await page.goto('http://localhost:5173/auth');
  await page.click('button:has-text("Play as Guest")');
  await page.waitForURL('**/lobby');
  await expect(page.locator('h1')).toContainText('Lobby');
});

test('registered user can create and validate a deck', async ({ page }) => {
  await page.goto('http://localhost:5173/auth');
  await page.click('button:has-text("Register")');
  const ts = Date.now();
  await page.fill('input[name="username"]', `Pilot${ts}`);
  await page.fill('input[name="email"]', `pilot${ts}@test.com`);
  await page.fill('input[name="password"]', 'password123');
  await page.click('button[type="submit"]:has-text("Register")');
  await page.waitForURL('**/lobby');
  await page.goto('http://localhost:5173/decks');
  await page.click('button:has-text("New Deck")');
  await page.waitForURL('**/decks/**');
  await expect(page.locator('h1, input[name="name"]')).toBeTruthy();
});
```

**Step 3: Run smoke tests**

```bash
npm run dev &
npx playwright test tests/smoke.test.ts --headed
```

Expected: both tests PASS.

**Step 4: Commit**

```bash
git add tests/ playwright.config.ts
git commit -m "test: add smoke tests for auth and deck builder"
```

---

## Task 18: Deploy to Production

**Files:**
- Create: `vercel.json` (or use SvelteKit adapter-vercel)
- Modify: `svelte.config.js`

**Step 1: Install Vercel adapter**

```bash
npm install -D @sveltejs/adapter-vercel
```

**Step 2: Update svelte.config.js**

```javascript
import adapter from '@sveltejs/adapter-vercel';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

export default {
  preprocess: vitePreprocess(),
  kit: { adapter: adapter() }
};
```

**Step 3: Create Supabase project**

Go to supabase.com → New Project. Note URL and anon key.

**Step 4: Push schema to production**

```bash
npx supabase db push --db-url postgresql://postgres:<password>@<host>:5432/postgres
```

**Step 5: Deploy Edge Functions**

```bash
npx supabase functions deploy --project-ref <project-ref>
```

**Step 6: Deploy frontend**

```bash
npx vercel --prod
```

Set environment variables in Vercel dashboard:
- `PUBLIC_SUPABASE_URL`
- `PUBLIC_SUPABASE_ANON_KEY`

**Step 7: Verify production**

Navigate to deployed URL, register an account, build a deck, create a room. Confirm Realtime updates work in two browser tabs.

**Step 8: Final commit**

```bash
git add svelte.config.js
git commit -m "feat: configure production deployment with Vercel adapter"
```
